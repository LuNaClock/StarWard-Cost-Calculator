<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星の翼 コストオーバー時の耐久値計算ツール</title>
    <!-- Google Fonts - Noto Sans JP (標準用) をインポート -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- Google Fonts - SF的なフォントをインポート -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Rajdhani:wght@600&display=swap" rel="stylesheet">
    <!-- Font Awesome (アイコン用) をインポート -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* 基本スタイルとカラースキーム */
        :root {
            /* SF感を意識したカラーパレット */
            --primary-dark: #1A2C3E; /* 濃いネイビー/チャコール */
            --primary-light: #00BFFF; /* 明るいスカイブルー (アクセント) */
            --accent-orange: #FFD700; /* ゴールドっぽいイエロー (アクセント) */
            --background-light: #F0F5F9; /* ごく薄いライトブルーグレー */
            --card-background: #FFFFFF;
            --text-color: #333333;
            --light-grey-border: #CED4DA; /* 明るいグレー */
            --medium-grey: #6C757D; /* 中間グレー */
            --soft-shadow: 0 8px 25px rgba(0, 0, 0, 0.15); /* 影を強調 */
            --transition-speed: 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* よりSF的なイージング */
            /* HPバーの色 (グラデーション用) */
            --hp-low: #dc3545; /* 赤 */
            --hp-medium: #ffc107; /* 黄 */
            --hp-high: #28a745; /* 緑 */
            --hp-pulse-color: rgba(220, 53, 69, 0.6); /* 低HP時の脈動色 */
            /* SF演出用追加カラー */
            --neon-glow: #00EFFF; /* ネオンブルー */
            --neon-glow-strong: #00BFFF; /* より強いネオンブルー */
            --glitch-color1: #FF00FF; /* マゼンタ */
            --glitch-color2: #00FFFF; /* シアン */
            --grid-line-color: rgba(0, 191, 255, 0.08); /* グリッド線の色 */
            --loading-spinner-color: #00BFFF;
        }

        /* ----- 基本スタイル ----- */
        body {
            font-family: 'Noto Sans JP', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.7; /* 読みやすく */
            color: var(--text-color);
            max-width: 1200px;
            margin: 0 auto;
            padding: 25px; /* パディングを増やす */
            background: linear-gradient(135deg, var(--primary-dark) 0%, #102030 100%); /* 暗めのSF背景 */
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden; /* 横スクロール防止 */
            position: relative;
            min-height: 100vh; /* 最小高さを確保 */
            z-index: 1; /* グリッドやノイズの上にコンテンツを配置 */
            /* 背景アニメーションを継続 */
            background-size: 200% 200%;
            animation: backgroundShift 60s ease-in-out infinite alternate;
            will-change: background-position; /* will-changeを追加 */
        }

        @keyframes backgroundShift {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        /* 背景の微細なグリッドパターンとノイズ */
        body::before, body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        body::before { /* グリッド */
            background-image: linear-gradient(to right, var(--grid-line-color) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-line-color) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.2;
            animation: gridPan 120s linear infinite;
            will-change: background-position; /* will-changeを追加 */
        }

        @keyframes gridPan {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 5000px 5000px;
            }
            /* 非常にゆっくり移動 */
        }

        body::after { /* ノイズオーバレイ */
            /* base64エンコードされたSVGノイズ */
            background-image: url('data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 40 40%27%3E%3Cfilter id=%27h%27%3E%3CfeTurbulence type=%27fractalNoise%27 baseFrequency=%27.8 .8%27 numOctaves=%271%27 seed=%272%27/%3E%3C/filter%3E%3Crect width=%27100%25%27 height=%27100%25%27 fill=%27url(%23h)%27 opacity=%270.05%27/%3E%3C/svg%3E');
            background-size: 200px;
            opacity: 0.1;
        }

        h1 {
            font-family: 'Orbitron', sans-serif; /* SFフォント適用 */
            color: var(--card-background); /* 背景に合わせて白色に */
            text-align: center;
            margin-bottom: 40px;
            font-size: 3.2em; /* さらに大きく */
            font-weight: 700;
            letter-spacing: 3px; /* 文字間を広げる */
            text-shadow: 0 0 15px rgba(0, 191, 255, 0.6); /* 常にわずかに光る */
            position: relative;
            z-index: 10; /* 最前面に */
            display: inline-block; /* text-shadowアニメーションのため */
            padding: 5px 0;
        }

        /* ----- H1タイトル SF演出 (初期ロード時のみ) ----- */
        .title-sf-effect {
            animation: neonGlowInitial 1.5s ease-in-out forwards, glitchTextInitial 2s linear forwards;
            will-change: transform, text-shadow, color; /* will-changeを追加 */
        }

        @keyframes neonGlowInitial {
            0% {
                text-shadow: 0 0 5px var(--neon-glow), 0 0 10px var(--neon-glow), 0 0 20px var(--neon-glow), 0 0 40px rgba(0, 239, 255, 0.4);
                color: var(--primary-light); /* 初期は強く発光 */
            }

            100% {
                text-shadow: 0 0 15px rgba(0, 191, 255, 0.6); /* 落ち着いた輝きに */
                color: var(--card-background);
            }
        }

        @keyframes glitchTextInitial {
            0% {
                transform: translate(0);
                text-shadow: none;
            }

            5% {
                transform: translate(-2px, 2px);
                text-shadow: 2px 0 0 var(--glitch-color1);
            }

            10% {
                transform: translate(2px, -2px);
                text-shadow: -2px 0 0 var(--glitch-color2);
            }

            15% {
                transform: translate(-1px, 1px);
                text-shadow: 1px 0 0 var(--glitch-color1);
            }

            20% {
                transform: translate(1px, -1px);
                text-shadow: -1px 0 0 var(--glitch-color2);
            }

            21% {
                transform: translate(0);
                text-shadow: none;
            }

            70% {
                transform: translate(0);
                text-shadow: none;
            }

            75% {
                transform: translate(3px, -3px);
                text-shadow: -3px 0 0 var(--glitch-color2);
            }

            80% {
                transform: translate(-3px, 3px);
                text-shadow: 3px 0 0 var(--glitch-color1);
            }

            85% {
                transform: translate(2px, -2px);
                text-shadow: -2px 0 0 var(--glitch-color2);
            }

            90% {
                transform: translate(-2px, 2px);
                text-shadow: 2px 0 0 var(--glitch-color1);
            }

            91% {
                transform: translate(0);
                text-shadow: none;
            }

            100% {
                transform: translate(0);
                text-shadow: none;
            }
        }

        /* ----- 使い方ガイド（旧description）のスタイル ----- */
        .usage-guide-container {
            background-color: var(--card-background);
            padding: 30px;
            margin-bottom: 50px;
            border-radius: 12px;
            box-shadow: var(--soft-shadow);
            transition: transform var(--transition-speed), box-shadow var(--transition-speed);
            position: relative;
            overflow: hidden; /* 背景アニメーション用 */
            border: 1px solid rgba(0, 191, 255, 0.2);
            will-change: transform, box-shadow; /* will-changeを追加 */
        }

            .usage-guide-container:hover {
                transform: translateY(-8px); /* ホバー時の浮遊感を強調 */
                box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
                border-color: var(--primary-light);
            }

            .usage-guide-container h2 {
                color: var(--primary-dark);
                font-size: 2.2em;
                font-weight: 700;
                margin-top: 0;
                margin-bottom: 30px;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px;
                text-shadow: 1px 1px 5px rgba(0,0,0,0.15);
                position: relative;
                z-index: 1;
            }

            .usage-guide-container .guide-intro {
                font-size: 1.15em;
                color: #555;
                margin-bottom: 35px;
                text-align: center;
                line-height: 1.8;
                position: relative;
                z-index: 1;
                max-width: 70ch;
                margin-left: auto;
                margin-right: auto;
            }

        /* ----- アコーディオンのスタイル ----- */
        .accordion {
            border: 1px solid var(--primary-light); /* SF感のあるボーダー */
            border-radius: 10px;
            overflow: hidden;
            background-color: #F8FCFF;
            box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.1);
        }

        .accordion-item {
            border-bottom: 1px solid rgba(0, 191, 255, 0.1);
        }

            .accordion-item:last-child {
                border-bottom: none;
            }

        .accordion-header {
            background-color: var(--background-light);
            color: var(--primary-dark);
            padding: 18px 25px; /* パディングを増やす */
            width: 100%;
            text-align: left;
            border: none;
            outline: none;
            cursor: crosshair; /* SFカーソル */
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 1.2em; /* さらに大きく */
            font-weight: 700;
            transition: all var(--transition-speed);
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            will-change: background-color, color, box-shadow; /* will-changeを追加 */
        }

            .accordion-header::before { /* ホバー・アクティブ時の光るボーダー */
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border-radius: 10px;
                box-shadow: 0 0 0 0px var(--neon-glow-strong);
                transition: box-shadow 0.3s ease-out;
                z-index: -1;
                will-change: box-shadow; /* will-changeを追加 */
            }

            .accordion-header:hover {
                background-color: #E6EEF4;
                color: var(--primary-light);
                box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.2);
            }

                .accordion-header:hover::before {
                    box-shadow: 0 0 15px 3px var(--neon-glow-strong);
                }

            .accordion-header.active {
                background-color: var(--primary-light);
                color: var(--card-background);
                box-shadow: inset 0 0 25px rgba(0, 191, 255, 0.5);
            }

                .accordion-header.active::before {
                    box-shadow: 0 0 20px 5px var(--neon-glow-strong);
                }

            .accordion-header span {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .accordion-header i:first-child {
                font-size: 1.4em;
                color: var(--accent-orange);
                transition: color var(--transition-speed);
            }

            .accordion-header.active i:first-child {
                color: var(--card-background);
            }

        .accordion-icon { /*共用アイコンスタイル*/
            font-size: 1.1em;
            transition: transform var(--transition-speed);
            will-change: transform; /* will-changeを追加 */
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg) scale(1.1); /* わずかに拡大 */
        }

        .accordion-content {
            background-color: var(--card-background);
            padding: 0 25px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), padding 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            color: #555;
            font-size: 1.05em;
            opacity: 0;
            transform: scaleY(0.8); /* 初期状態で縮小 */
            transform-origin: top;
            will-change: max-height, padding, opacity, transform; /* will-changeを追加 */
        }

            .accordion-content.show {
                max-height: 500px; /* 十分な高さに設定 */
                padding: 25px;
                opacity: 1;
                transform: scaleY(1); /* 表示時に元のサイズに */
            }

            .accordion-content p {
                max-width: 70ch; /* 読みやすい行長に制限 */
                margin: 0 auto 12px; /* 中央揃えにして上下マージン */
                line-height: 1.9; /* 行の高さを少し広げて読みやすく */
                transform: scaleY(1.03);
                transform-origin: top center; /* スケール原点を設定 */
            }

                .accordion-content p:last-child {
                    margin-bottom: 0;
                }

            .accordion-content .formula {
                background-color: #F0F8FF;
                border-left: 6px solid var(--accent-orange);
                padding: 15px 20px;
                margin: 20px auto; /* 中央揃えに */
                max-width: 650px; /* 計算式ブロックの最大幅も制限 */
                border-radius: 8px;
                font-size: 1.2em;
                font-weight: 700;
                color: var(--primary-dark);
                text-align: center;
                box-shadow: 0 4px 10px rgba(0,0,0,0.12);
                font-family: 'Rajdhani', sans-serif; /* SFフォント適用 */
            }

            .accordion-content .tip {
                font-style: italic;
                color: var(--medium-grey);
                font-size: 0.98em;
                display: flex;
                align-items: flex-start;
                gap: 12px;
                margin-top: 25px;
                background-color: #FDFCDC;
                border-radius: 8px;
                padding: 12px 18px;
                border: 1px solid #FFECB3;
                box-shadow: 0 3px 8px rgba(0,0,0,0.1);
                max-width: 70ch;
                margin-left: auto;
                margin-right: auto;
            }

        /* ----- 検索・フィルタリング・ソート ----- */
        .controls-container {
            display: flex;
            flex-direction: column;
            margin-bottom: 50px;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 10px;
            margin-top: 20px; /* 追加: 検索欄の上のスペース */
            margin-bottom: 20px; /* 追加: 検索欄の下のスペース */
        }

        .search-icon {
            position: absolute;
            left: 20px; /* パディングに合わせて調整 */
            color: var(--primary-light);
            font-size: 1.3em;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 191, 255, 0.6);
            will-change: transform, opacity, text-shadow; /* will-changeを追加 */
        }

        #characterSearch {
            width: 100%;
            padding: 16px 20px 16px 60px; /* アイコン分のスペースを確保 */
            border: 2px solid var(--light-grey-border); /* ボーダーを太く */
            border-radius: 10px;
            font-size: 1.1em;
            background-color: var(--card-background);
            box-sizing: border-box;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.08); /* 通常時のshadow */
            will-change: border-color, box-shadow; /* will-changeを追加 */
        }

            #characterSearch:focus {
                border-color: var(--primary-light);
                outline: none;
            }
        /* 検索結果なしメッセージ */
        .no-results-message {
            text-align: center;
            color: #E74C3C;
            font-size: 1.3em;
            padding: 30px;
            opacity: 0; /* 初期非表示 */
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            will-change: transform, opacity, text-shadow; /* will-changeを追加 */
        }

        @keyframes glitchDisplay {
            0% {
                transform: translate(0);
                opacity: 0;
            }

            10% {
                transform: translate(-2px, 2px);
                text-shadow: 2px 0 0 var(--glitch-color1);
                opacity: 1;
            }

            20% {
                transform: translate(2px, -2px);
                text-shadow: -2px 0 0 var(--glitch-color2);
            }

            30% {
                transform: translate(-1px, 1px);
                text-shadow: 1px 0 0 var(--glitch-color1);
            }

            40% {
                transform: translate(1px, -1px);
                text-shadow: -1px 0 0 var(--glitch-color2);
                opacity: 1;
            }

            50% {
                transform: translate(0);
                text-shadow: none;
                opacity: 1;
            }

            100% {
                transform: translate(0);
                text-shadow: none;
                opacity: 1;
            }
        }

        .filter-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: flex-start;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            width: 100%;
            justify-content: flex-start;
        }

        .filter-label {
            font-weight: bold;
            white-space: nowrap;
            color: var(--card-background);
            font-size: 1.05em;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.4);
        }

            .filter-label i {
                color: var(--accent-orange);
                font-size: 1.2em;
                animation: bounceIcon 1.5s ease-in-out infinite alternate;
                will-change: transform; /* will-changeを追加 */
            }

            .filter-label:nth-of-type(2) i {
                animation-delay: 0.15s; /* アイコンのバウンスに遅延 */
            }

        @keyframes bounceIcon {
            0%, 100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        .filter-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-button {
            background-color: var(--light-grey-border);
            border: 2px solid var(--light-grey-border);
            padding: 12px 20px; /* パディングを増やす */
            border-radius: 30px; /* 角丸を大きく */
            cursor: crosshair; /* SFカーソル */
            transition: all var(--transition-speed);
            font-size: 1em;
            color: var(--text-color);
            white-space: nowrap;
            min-width: 80px; /* 最小幅を確保 */
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.12); /* 影を強調 */
            position: relative;
            overflow: hidden;
            will-change: transform, background-color, box-shadow, color; /* will-changeを追加 */
        }

            .filter-button i { /* 動的に追加されるアイコンのスタイル */
                margin-left: 8px; /* テキストとアイコンの間隔 */
                font-size: 0.9em; /* テキストに合わせたサイズ */
                color: var(--text-color); /* デフォルト色 */
                transition: color 0.3s ease;
            }

            .filter-button.active i {
                color: var(--card-background); /* アクティブ時の色 */
            }

            .filter-button::after { /* 波紋エフェクト */
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 5px;
                height: 5px;
                background: rgba(255, 255, 255, 0.6);
                border-radius: 50%;
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
                transition: transform 0.6s ease-out, opacity 0.6s ease-out;
                z-index: 1;
                will-change: transform, opacity; /* will-changeを追加 */
            }

            .filter-button:active::after {
                transform: translate(-50%, -50%) scale(20);
                opacity: 1;
                transition: 0s; /* クリック時に即時表示 */
            }

            .filter-button::before { /* 光沢アニメーション */
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
                transform: skewX(-20deg);
                transition: all 0.5s ease;
                z-index: 1;
                will-change: transform, left;
            }

            .filter-button:hover::before {
                left: 100%;
            }

            .filter-button.active {
                background-color: var(--primary-light);
                color: var(--card-background);
                box-shadow: 0 5px 15px rgba(0, 191, 255, 0.5); /* アクティブ時の影を強調 */
                border-color: var(--primary-light);
                font-weight: bold;
                background-image: linear-gradient(45deg, rgba(0, 191, 255, 0.8) 0%, rgba(0, 150, 200, 0.8) 100%);
                background-size: 200% 200%;
                animation: activeButtonGlow 4s ease-in-out infinite alternate;
                will-change: background-position, box-shadow; /* will-changeを追加 */
            }

        @keyframes activeButtonGlow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        .filter-button:hover:not(.active) {
            background-color: #E6EEF4;
            transform: translateY(-5px); /* 浮遊感を強調 */
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
            border-color: var(--medium-grey);
        }

        .filter-button.active:hover {
            background-color: #008DCC;
            transform: translateY(-5px);
        }

        .filter-button:active {
            transform: translateY(2px) scale(0.97); /* 押下感を強調 */
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            border-color: var(--primary-light);
        }

        /* ----- キャラクターグリッドとカード ----- */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); /* さらに大きく */
            gap: 35px; /* 間隔を広げる */
            margin-top: 50px;
        }

        .character-card {
            background-color: var(--card-background);
            border-radius: 15px; /* 角丸を大きく */
            box-shadow: var(--soft-shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed);
            position: relative;
            border: 2px solid rgba(0, 191, 255, 0.1);
            background-image: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,245,249,0.9)); /* 薄いグラデーション */
            will-change: transform, box-shadow, opacity; /* will-changeを追加 */
        }

            .character-card::before { /* ボーダーに沿って光るエフェクト */
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 15px;
                background: linear-gradient(45deg, var(--neon-glow-strong) 0%, transparent 50%, var(--neon-glow-strong) 100%);
                background-size: 400% 400%;
                z-index: -1;
                opacity: 0.2; /* 常時薄く発光 */
                animation: cardBorderFlow 8s linear infinite;
                will-change: background-position, opacity; /* will-changeを追加 */
            }

            .character-card:hover::before {
                opacity: 0.8; /* ホバーで強く発光 */
            }

        @keyframes cardBorderFlow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        .character-card:hover {
            transform: translateY(-15px) scale(1.02) rotateZ(1deg); /* 浮遊感とわずかな拡大・回転 */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            border-color: var(--primary-light);
        }

        .character-header {
            background-color: var(--primary-dark);
            color: var(--card-background);
            padding: 18px 30px; /* パディングを増やす */
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-size: 1.2em;
            font-family: 'Rajdhani', sans-serif; /* SFフォント適用 */
        }

        .character-cost {
            background-color: var(--accent-orange);
            color: var(--primary-dark);
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.95em;
            font-weight: 700;
            box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.4);
        }

        .character-body {
            padding: 30px; /* パディングを増やす */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .character-image {
            width: 120px; /* さらに大きく */
            height: 120px;
            background-color: #F0F5F9;
            border-radius: 50%;
            margin: 0 auto 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 60px;
            color: #7F8C8D;
            font-weight: 700;
            border: 4px solid var(--primary-light); /* ボーダーを太く */
            box-shadow: 0 0 0 4px rgba(0, 191, 255, 0.3), inset 0 0 12px rgba(0,0,0,0.18);
            overflow: hidden;
            transition: all var(--transition-speed);
            will-change: transform, box-shadow; /* will-changeを追加 */
        }

            .character-image:hover {
                transform: scale(1.1) rotateZ(5deg); /* より強調された拡大と回転 */
                box-shadow: 0 0 0 6px rgba(0, 191, 255, 0.6), inset 0 0 15px rgba(0,0,0,0.25);
            }

            .character-image img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 50%;
                display: block;
            }

            .character-image span.initial {
                width: 100%;
                height: 100%;
                display: flex; /* 初期は表示 (画像がない場合や読み込み失敗時) */
                justify-content: center;
                align-items: center;
                font-family: 'Orbitron', sans-serif;
            }

        .character-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            padding: 10px 0;
            border-bottom: 1px solid var(--light-grey-border);
            font-weight: 500;
        }

        .character-hp {
            font-family: 'Rajdhani', sans-serif; /* SFフォント適用 */
            font-weight: 700;
            color: #E74C3C;
            font-size: 1.3em; /* さらに大きく */
            cursor: crosshair; /* SFカーソル */
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px rgba(231, 76, 60, 0.3);
            will-change: color, text-shadow, transform; /* will-changeを追加 */
        }

            .character-hp:hover {
                color: var(--primary-light);
                text-shadow: 0 0 12px rgba(0, 191, 255, 0.7); /* ホバー時のグロー */
            }

            .character-hp:active {
                transform: translateY(2px) scale(0.96);
                color: #C0392B;
            }
            .character-hp.animating {
                animation: hpNumberPop 0.8s ease-out forwards;
                will-change: transform;
            }

        @keyframes hpNumberPop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }

            100% {
                transform: scale(1);
            }
        }


        /* ----- HPバーのスタイル ----- */
        .hp-bar-container {
            width: 100%;
            height: 12px; /* さらに太く */
            background-color: #E0E0E0;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 5px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.2);
            position: relative;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(to right, var(--hp-low) 0%, var(--hp-medium) 50%, var(--hp-high) 100%), linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0) 100%);
            background-size: 100% 100%, 50% 100%;
            background-repeat: no-repeat;
            background-position: left center, -50% center;
            transform-origin: left;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            animation: hpShineBackground 2.5s linear infinite;
            will-change: transform, background-position;
        }

        @keyframes hpShineBackground {
            0% {
                background-position: left center, -50% center;
            }
            100% {
                background-position: left center, 150% center;
            }
        }
        .hp-bar-low-pulse {
            animation: hpPulse 1.2s ease-in-out infinite alternate;
            box-shadow: 0 0 15px 5px var(--hp-pulse-color);
            will-change: box-shadow;
        }

        @keyframes hpPulse {
            0% {
                box-shadow: 0 0 10px 3px var(--hp-pulse-color);
            }

            100% {
                box-shadow: 0 0 20px 8px var(--hp-pulse-color);
            }
        }

        /* ----- HP割合表示のスタイル (新しく追加) ----- */
        .hp-percentage-display {
            text-align: center;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2em; /* 割合の文字サイズ */
            font-weight: 700;
            color: var(--primary-light);
            margin-top: 5px;
            margin-bottom: 20px; /* 下のテーブルとの間隔 */
            text-shadow: 0 0 8px rgba(0, 191, 255, 0.5);
            position: relative;
            z-index: 2;
            pointer-events: none;
            opacity: 0; /* 初期非表示 */
            transition: opacity 0.3s ease; /* フェードイン/アウト */
        }

            .hp-percentage-display.show {
                opacity: 1;
            }

        /* ----- テーブルスタイル ----- */
        .cost-table {
            width: 100%;
            border-collapse: separate; /* border-radiusのために */
            border-spacing: 0;
            margin-top: 20px;
            font-size: 1em;
            border-radius: 8px;
            overflow: hidden; /* 角丸対応 */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

            .cost-table th, .cost-table td {
                padding: 15px 8px;
                text-align: center;
                font-size: 0.95em;
            }

            .cost-table th {
                background-color: var(--primary-light);
                color: var(--card-background);
                font-weight: 700;
                border-bottom: 1px solid rgba(255,255,255,0.4);
                white-space: nowrap;
                font-family: 'Rajdhani', sans-serif; /* SFフォント適用 */
            }

                .cost-table th:first-child {
                    border-top-left-radius: 8px;
                }

                .cost-table th:last-child {
                    border-top-right-radius: 8px;
                }

            .cost-table td {
                border-top: 1px solid var(--light-grey-border);
                color: var(--text-color);
                cursor: crosshair; /* SFカーソル */
                transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
                position: relative;
                background-color: var(--card-background);
                will-change: background-color, color, box-shadow, transform; /* will-changeを追加 */
            }

            .cost-table tr:nth-child(even) td {
                background-color: #F8FCFF;
            }

            .cost-table td:hover {
                background-color: #EBF7FF;
                color: var(--primary-dark);
                box-shadow: inset 0 0 10px rgba(0, 191, 255, 0.3); /* ホバー時の内側の影を強調 */
                transform: translateY(-2px); /* わずかに浮遊 */
            }

            .cost-table td.active-hp-display {
                background-color: #D3EEFF;
                font-weight: bold;
                color: var(--hp-low);
                box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.4);
                border: 1px solid var(--primary-light);
                transform: translateY(0);
                animation: cellFlash 0.3s ease-out;
            }
        @keyframes cellFlash {
            0% {
                background-color: #D3EEFF;
                box-shadow: inset 0 0 30px rgba(0, 191, 255, 0.8), 0 0 20px 5px rgba(0, 191, 255, 0.8);
            }

            100% {
                background-color: #D3EEFF;
                box-shadow: inset 0 0 20px rgba(0, 191, 255, 0.6), 0 0 10px 3px rgba(0, 191, 255, 0.5);
            }
        }

        .cost-table tr:last-child td:first-child {
            border-bottom-left-radius: 8px;
        }

        .cost-table tr:last-child td:last-child {
            border-bottom-right-radius: 8px;
        }

        /* ----- ローディングインジケーターのスタイル ----- */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 44, 62, 0.8); /* primary-darkの半透明 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            -webkit-backdrop-filter: blur(5px); /* Safari対応 */
            backdrop-filter: blur(5px); /* 背景をぼかす */
            will-change: opacity, visibility, backdrop-filter; /* will-changeを追加 */
        }

            .loading-overlay.active {
                opacity: 1;
                visibility: visible;
            }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top: 5px solid var(--loading-spinner-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: relative;
            box-shadow: 0 0 15px var(--loading-spinner-color);
            will-change: transform, box-shadow; /* will-changeを追加 */
        }

            .loading-spinner::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 15px;
                height: 15px;
                background-color: var(--loading-spinner-color);
                border-radius: 50%;
                box-shadow: 0 0 10px var(--loading-spinner-color);
            }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* ----- フッターのスタイル ----- */
        footer {
            text-align: center;
            margin-top: 80px; /* マージンを増やす */
            padding: 30px 0;
            border-top: 1px solid rgba(0, 191, 255, 0.2);
            color: var(--medium-grey);
            font-size: 0.95em; /* 少し大きく */
            letter-spacing: 1px;
            opacity: 0.7;
            background-color: rgba(0,0,0,0.1); /* 半透明の背景 */
            position: relative;
            z-index: 1;
        }

            footer a {
                color: var(--medium-grey);
                text-decoration: none;
                transition: color var(--transition-speed);
            }

                footer a:hover {
                    color: var(--primary-light);
                    text-shadow: 0 0 8px rgba(0, 191, 255, 0.5);
                }

        /* ----- 新規追加: 再出撃シミュレーションセクション ----- */
        .simulation-container {
            background-color: var(--card-background);
            padding: 30px;
            margin-bottom: 50px;
            border-radius: 12px;
            box-shadow: var(--soft-shadow);
            border: 1px solid rgba(0, 191, 255, 0.2);
            position: relative;
            overflow: hidden;
            will-change: transform, box-shadow;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed);
        }

            .simulation-container:hover {
                transform: translateY(-8px);
                box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
                border-color: var(--primary-light);
            }

            .simulation-container h2 {
                color: var(--primary-dark);
                font-size: 2.2em;
                font-weight: 700;
                margin-top: 0;
                margin-bottom: 30px;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px;
                text-shadow: 1px 1px 5px rgba(0,0,0,0.15);
                position: relative;
                z-index: 1;
            }

            .simulation-container .guide-intro {
                font-size: 1.15em;
                color: #555;
                margin-bottom: 35px;
                text-align: center;
                line-height: 1.8;
                max-width: 70ch;
                margin-left: auto;
                margin-right: auto;
            }

        .character-select-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
        }

        .select-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 250px;
        }

            .select-wrapper label {
                font-weight: bold;
                color: var(--primary-dark);
                font-size: 1.1em;
                display: flex;
                align-items: center;
                gap: 10px;
            }

                .select-wrapper label i {
                    color: var(--accent-orange);
                    font-size: 1.2em;
                }

        .select-dropdown {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--light-grey-border);
            border-radius: 8px;
            background-color: var(--background-light);
            font-size: 1em;
            color: var(--text-color);
            -webkit-appearance: none; /* Safari対応 */
            -moz-appearance: none; /* Firefox対応 */
            appearance: none; /* デフォルトの矢印を非表示 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%236C757D' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E"); /* カスタム矢印 */
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 18px;
            cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.08);
            will-change: border-color, box-shadow;
        }

            .select-dropdown:focus {
                border-color: var(--primary-light);
                outline: none;
                box-shadow: 0 0 0 3px rgba(0, 191, 255, 0.3);
            }

        /* Make number input fields look like select-dropdown */
        input[type="number"].select-dropdown {
            -moz-appearance: textfield; /* Firefox */
        }
        input[type="number"].select-dropdown::-webkit-outer-spin-button,
        input[type="number"].select-dropdown::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }


        .team-cost-display {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px 20px;
            background-color: #F0F8FF;
            border-radius: 10px;
            border: 1px solid var(--primary-light);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            will-change: transform, box-shadow;
            transition: all 0.3s ease;
        }

            .team-cost-display:hover {
                transform: scale(1.01);
                box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            }

            .team-cost-display .cost-label {
                font-size: 1.2em;
                font-weight: 700;
                color: var(--primary-dark);
                display: flex;
                align-items: center;
                gap: 8px;
            }

                .team-cost-display .cost-label i {
                    color: var(--neon-glow-strong);
                    font-size: 1.3em;
                }

            .team-cost-display .cost-value {
                font-family: 'Orbitron', sans-serif;
                font-size: 2.2em;
                font-weight: 700;
                color: var(--primary-light);
                text-shadow: 0 0 10px rgba(0, 191, 255, 0.7);
                letter-spacing: 1px;
                transition: text-shadow 0.3s ease;
            }

        .selected-characters-display {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            margin-top: 30px;
            margin-bottom: 40px;
            min-height: 180px; /* ある程度の高さを確保 */
            align-items: center; /* 垂直方向中央揃え */
        }

        .mini-character-card {
            background-color: #F8FCFF;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 15px;
            text-align: center;
            width: 180px; /* ミニカードの固定幅 */
            border: 1px solid var(--light-grey-border);
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0; /* 初期非表示 */
            transform: translateY(20px); /* アニメーション用 */
            transition: all 0.3s ease;
            will-change: opacity, transform;
        }

            .mini-character-card.active {
                opacity: 1;
                transform: translateY(0);
            }

            .mini-character-card .char-name {
                font-weight: 700;
                color: var(--primary-dark);
                font-size: 1.1em;
                margin-bottom: 8px;
                font-family: 'Rajdhani', sans-serif;
            }

            .mini-character-card .char-image {
                width: 80px;
                height: 80px;
                border-radius: 50%;
                border: 3px solid var(--accent-orange);
                overflow: hidden;
                margin-bottom: 10px;
                box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3), inset 0 0 8px rgba(0,0,0,0.1);
                will-change: transform, box-shadow;
                transition: all 0.3s ease;
            }

                .mini-character-card .char-image:hover {
                    transform: scale(1.05) rotateZ(3deg);
                    box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.5), inset 0 0 10px rgba(0,0,0,0.15);
                }

                .mini-character-card .char-image img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 50%;
                    display: block;
                }

                .mini-character-card .char-image span.initial {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    width: 100%;
                    height: 100%;
                    font-size: 36px;
                    color: #7F8C8D;
                    background-color: #F0F5F9;
                    font-family: 'Orbitron', sans-serif;
                }

            .mini-character-card .char-cost {
                font-weight: 700;
                color: var(--primary-light);
                font-family: 'Rajdhani', sans-serif;
                font-size: 0.95em;
                background-color: rgba(0, 191, 255, 0.1);
                padding: 4px 10px;
                border-radius: 15px;
                border: 1px solid rgba(0, 191, 255, 0.3);
            }

        .simulation-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 30px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

            .simulation-input-group label {
                font-weight: bold;
                color: var(--primary-dark);
                font-size: 1.1em;
                display: flex;
                align-items: center;
                gap: 10px;
            }

                .simulation-input-group label i {
                    color: var(--accent-orange);
                    font-size: 1.2em;
                }
        /* Awakening specific input groups */
        .awakening-simulation-area .simulation-input-group {
            max-width: none; /* Allow full width within its container */
            margin-bottom: 15px;
        }
        .awakening-additional-options { /* Container for new checkbox groups */
            display: flex;
            flex-direction: column; /* Default to vertical stacking */
            gap: 10px; /* Space between checkbox groups */
            text-align: left;
            max-width: 450px; /* Control width of this section */
            margin: 15px auto; /* Center the section */
        }

        .awakening-additional-options .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .awakening-additional-options .checkbox-group label {
            font-weight: normal;
            font-size: 1em;
            margin-bottom: 0;
            margin-left: 5px; /* Space between icon/checkbox and text */
        }
        .awakening-additional-options .checkbox-group input[type="checkbox"] {
            margin-right: 0; /* Remove default margin if icon is present */
            transform: scale(1.2);
            cursor: pointer;
        }
         .awakening-additional-options .checkbox-group > i {
            color: var(--accent-orange);
            font-size: 1.2em;
            width: 20px; /* Ensure icon has some width */
            text-align: center;
        }

        .awakening-additional-options .select-dropdown-container {
             margin-left: 30px; /* Indent dropdown if it's under a checkbox with icon */
             margin-top: 5px;
             display: none;
        }

        /* Responsive layout for awakening options */
        @media (min-width: 768px) { /* Apply for wider screens */
            .awakening-additional-options {
                flex-direction: row; /* Stack horizontally */
                flex-wrap: wrap; /* Allow wrapping if not enough space */
                justify-content: space-around; /* Distribute space */
                align-items: flex-start;
                gap: 20px; /* Adjust gap for horizontal layout */
                max-width: none; /* Allow to use more width */
            }
            .awakening-additional-options .simulation-input-group.checkbox-group {
                /* Adjust width for horizontal items if needed, e.g., flex-basis */
                 min-width: 200px; /* Example minimum width */
            }
            .awakening-additional-options .select-dropdown-container {
                width: 100%; /* Make dropdown take full width of its parent group if needed */
                margin-left: 0; /* Reset indent if it's part of a horizontal group */
            }
             /* If a checkbox group has a dropdown, make them stack vertically even in horizontal layout */
            .awakening-additional-options .simulation-input-group.has-dropdown {
                display: flex;
                flex-direction: column;
                align-items: flex-start; /* Align checkbox and dropdown to the left */
            }
            .awakening-additional-options .simulation-input-group.has-dropdown .select-dropdown-container {
                 margin-left: 30px; /* Re-apply indent for dropdown */
            }
        }



        .simulation-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
        }

        .simulation-button {
            background-color: var(--primary-light);
            color: var(--card-background);
            border: 2px solid var(--primary-light);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: crosshair;
            transition: all var(--transition-speed);
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.5);
            position: relative;
            overflow: hidden;
            will-change: transform, background-color, box-shadow;
        }

            .simulation-button:hover {
                background-color: #008DCC;
                transform: translateY(-5px) scale(1.01);
                box-shadow: 0 8px 20px rgba(0, 191, 255, 0.7);
            }

            .simulation-button:active {
                transform: translateY(2px) scale(0.98);
                box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            }

            .simulation-button::before { /* 光沢アニメーション */
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
                transform: skewX(-20deg);
                transition: all 0.5s ease;
                z-index: 1;
                will-change: transform, left;
            }

            .simulation-button:hover::before {
                left: 100%;
            }

        .simulation-results {
            background-color: #F8FCFF;
            padding: 30px;
            border-radius: 12px;
            box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.1);
            text-align: center;
            opacity: 0; /* 初期非表示 */
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            will-change: opacity, transform;
            pointer-events: none; /* デフォルトでクリック不可に */
        }

            .simulation-results.active {
                opacity: 1;
                transform: translateY(0);
                pointer-events: auto; /* 表示時にクリック可能に */
            }

            .simulation-results h3 {
                color: var(--primary-dark);
                font-size: 2em;
                font-weight: 700;
                margin-top: 0;
                margin-bottom: 25px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                text-shadow: 1px 1px 5px rgba(0,0,0,0.1);
            }

                .simulation-results h3 i {
                    color: var(--primary-light);
                    font-size: 1.2em;
                }

        .result-display-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px 20px;
            margin-bottom: 25px;
            text-align: left;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .redeploy-char-info {
            display: flex;
            flex-direction: column;
            background-color: #E6EEF4;
            padding: 12px 18px;
            border-radius: 8px;
            border: 1px solid rgba(0, 191, 255, 0.1);
            box-shadow: inset 0 1px 5px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease;
            will-change: background-color;
        }

            .redeploy-char-info:hover {
                background-color: #DDEBF6;
            }

            .redeploy-char-info .info-label {
                font-weight: bold;
                color: var(--medium-grey);
                font-size: 0.9em;
                margin-bottom: 5px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .redeploy-char-info .info-value {
                font-family: 'Rajdhani', sans-serif;
                font-size: 1.4em;
                font-weight: 700;
                color: var(--primary-dark);
                text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
            }
        /* 特定の強調表示 */
        #redeployCalculatedHp.low-hp-value {
            color: var(--hp-low);
            text-shadow: 0 0 8px rgba(220, 53, 69, 0.5);
            animation: hpNumberPop 0.8s ease-out forwards;
        }
        /* 新規追加: 99%以下の赤い文字表示用クラス */
        #redeployCalculatedHp.red-value {
            color: var(--hp-low); /* hp-lowは赤色 */
            text-shadow: 0 0 8px rgba(220, 53, 69, 0.5); /* 赤い影 */
            animation: none; /* low-hp-valueのanimationが競合しないように */
        }

        .simulation-hp-bar { /* シミュレーション結果のHPバー */
            width: 80%; /* 幅を調整 */
            max-width: 600px; /* 最大幅 */
            margin: 25px auto 10px; /* 中央揃えとマージン */
            border: 2px solid var(--primary-light); /* 強調 */
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.5);
            height: 16px; /* 太く */
        }

        .simulation-hp-percentage { /* シミュレーション結果の割合表示 */
            font-size: 1.5em; /* 大きく */
            margin-top: 10px; /* 上のバーとの間隔 */
            color: var(--primary-dark); /* 暗い色 */
            text-shadow: none; /* デフォルトの影を解除 */
            font-family: 'Orbitron', sans-serif; /* SFフォント */
            font-weight: 700;
        }

        .simulation-note {
            color: var(--medium-grey);
            font-size: 0.9em;
            margin-top: 20px;
        }

        /* ----- 新規追加: 合計耐久力表示エリア ----- */
        .total-hp-display-area {
            margin-top: 40px;
            padding: 30px;
            border-top: 1px dashed var(--light-grey-border);
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            will-change: opacity, transform;
            background-color: #F8FCFF;
            border-radius: 12px;
            border: 1px solid var(--accent-orange);
            box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.1);
        }

            .total-hp-display-area.active {
                opacity: 1;
                transform: translateY(0);
            }

            .total-hp-display-area h3 {
                color: var(--accent-orange);
                font-size: 1.8em;
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                text-shadow: 1px 1px 5px rgba(0,0,0,0.1);
            }

                .total-hp-display-area h3 i {
                    color: var(--accent-orange);
                }

        .total-hp-summary {
            font-size: 1.05em;
            color: #666;
            margin-bottom: 25px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

            .total-hp-summary .cost-value-small {
                font-family: 'Orbitron', sans-serif;
                font-size: 1.2em;
                font-weight: 700;
                color: var(--primary-light);
                text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
                margin-left: 5px;
                margin-right: 5px;
            }

        .total-hp-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-bottom: 25px;
            text-align: left;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }
        @media (max-width: 1200px) {
             .total-hp-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 920px) {
            .total-hp-grid {
                grid-template-columns: repeat(2, 1fr);
                 max-width: 700px;
            }
        }
        @media (max-width: 650px) {
            .total-hp-grid {
                grid-template-columns: 1fr;
                max-width: 400px;
            }
        }


        .total-hp-scenario {
            background-color: #E6EEF4;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 191, 255, 0.1);
            box-shadow: inset 0 1px 5px rgba(0,0,0,0.05);
            margin-bottom: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
        }

            .total-hp-scenario h4 {
                color: var(--primary-dark);
                font-size: 1.3em;
                font-weight: 700;
                margin-top: 0;
                margin-bottom: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

                .total-hp-scenario h4 i {
                    color: var(--accent-orange);
                }

            .total-hp-scenario .redeploy-char-info {
                background-color: #F0F8FF;
                margin-bottom: 10px;
                flex-shrink: 0;
            }

                .total-hp-scenario .redeploy-char-info:last-of-type {
                    margin-bottom: 0;
                }
            /* NEW: Total HP Accordion Styles */
            .total-hp-accordion-header {
                background-color: transparent;
                border: none;
                border-bottom: 1px dashed rgba(0,0,0,0.1);
                padding: 10px 0 8px 0;
                width: 100%;
                text-align: left;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-top: 15px;
                margin-bottom: 0;
                outline: none;
                transition: background-color 0.3s ease;
            }
            .total-hp-accordion-header:hover {
                background-color: rgba(0, 191, 255, 0.05);
            }
            .total-hp-accordion-title {
                color: var(--primary-dark);
                font-size: 1.1em;
                font-weight: 600;
            }
            .total-hp-accordion-header .accordion-icon {
                font-size: 1em;
                color: var(--primary-dark);
            }

            .total-hp-accordion-content {
                list-style: none;
                font-size: 0.95em;
                color: var(--text-color);
                text-align: left;
                overflow-y: auto;
                max-height: 0; /* Closed by default */
                border-style: solid;
                border-color: var(--light-grey-border);
                border-width: 0px; /* Closed by default */
                border-radius: 5px;
                background-color: var(--card-background);
                scrollbar-width: thin;
                scrollbar-color: var(--primary-light) #f1f1f1;
                opacity: 0; /* Closed by default */
                padding: 0; /* Closed by default */
                margin: 0; /* Closed by default */
                transition: max-height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                            opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                            padding 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                            margin-top 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                            border-width 0.4s ease;
            }
            .total-hp-accordion-content.show {
                max-height: 300px;
                opacity: 1;
                padding: 8px;
                margin-top: 10px;
                border-width: 1px;
            }

            .total-hp-accordion-content::-webkit-scrollbar { width: 10px; }
            .total-hp-accordion-content::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
            .total-hp-accordion-content::-webkit-scrollbar-thumb { background: var(--primary-light); border-radius: 10px; }
            .total-hp-accordion-content::-webkit-scrollbar-thumb:hover { background: #008DCC; }

            .total-hp-accordion-content li {
                background-color: var(--card-background);
                padding: 6px 10px;
                border-radius: 5px;
                margin-bottom: 5px;
                border: 1px solid var(--light-grey-border);
                box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
                white-space: normal;
                word-break: break-word;
            }
            .total-hp-accordion-content li:last-child {
                margin-bottom: 0;
            }
            .total-hp-accordion-content li:hover {
                transform: translateX(5px);
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            }

            .total-hp-scenario .info-label {
                font-size: 0.85em;
            }

            .total-hp-scenario .info-value {
                font-size: 1.3em;
            }

        @media (max-width: 480px) {
            .total-hp-display-area h3 {
                font-size: 1.4em;
            }
            .total-hp-summary {
                font-size: 0.95em;
            }
            .total-hp-scenario h4 {
                font-size: 1.2em;
            }
            .total-hp-scenario .info-value {
                font-size: 1.1em;
            }
        }

        /* NEW Awakening Simulation Area Styles */
        .awakening-simulation-area {
            display: none; /* Initially hidden */
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px dashed var(--light-grey-border);
        }
        .simulation-results.active .awakening-simulation-area {
            display: block; /* Show when results are active */
        }

        .awakening-possible {
            color: var(--hp-high) !important; /* Greenish color, !important to override other styles */
            text-shadow: 0 0 8px rgba(40, 167, 69, 0.5) !important;
            font-weight: bold;
        }
        .awakening-not-possible {
            color: var(--hp-low) !important; /* Reddish color, !important to override other styles */
            text-shadow: 0 0 8px rgba(220, 53, 69, 0.5) !important;
            font-weight: bold;
        }
        .awakening-simulation-area .simulation-input-group label {
             margin-bottom: 8px;
        }
        .awakening-additional-options .simulation-input-group {
            margin-bottom: 10px; /* Reduced margin for checkbox groups */
        }
        .awakening-additional-options .select-dropdown-container {
            margin-left: 25px; /* Indent dropdown under checkbox */
            margin-top: 5px;
            display: none; /* Hidden by default */
        }
        .awakening-additional-options .checkbox-group {
            align-items: center; /* Vertically align checkbox and label */
        }
        .awakening-additional-options .checkbox-group label {
            font-weight: normal; /* Less emphasis for checkbox label */
            margin-left: 5px;
        }

    </style>
</head>
<body>
    <main>
        <h1 class="title-sf-effect">星の翼 コストオーバー時の耐久値計算ツール</h1>

        <div class="usage-guide-container">
            <h2><i class="fas fa-question-circle"></i> ツールの使い方ガイド</h2>
            <p class="guide-intro">このツールは、ゲーム「星の翼」でコストオーバーが起こって再出撃した際の耐久値を計算します。以下の手順でご利用ください。</p>

            <div class="accordion">
                <div class="accordion-item">
                    <button class="accordion-header" aria-expanded="false">
                        <span><i class="fas fa-search"></i> 1. キャラクターを検索・絞り込む</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <div class="accordion-content">
                        <p>上部の検索ボックスにキャラクター名を入力するか、コストフィルターや並び替えオプションを使って目的のキャラクターを素早く見つけられます。</p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header" aria-expanded="false">
                        <span><i class="fas fa-calculator"></i> 2. 計算式と本来の耐久値を確認する</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <div class="accordion-content">
                        <p>各キャラクターカードには、コストオーバー時の耐久値を計算するための基本情報が表示されます。計算式は以下の通りです。</p>
                        <p class="formula"><strong>再出撃時耐久値 = 本来の耐久値 × (残りコスト ÷ キャラクターのコスト)</strong></p>
                        <p>「本来の耐久値」はキャラクターカードのHPバーの上に大きく表示されています。</p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header" aria-expanded="false">
                        <span><i class="fas fa-chart-bar"></i> 3. HPバーの変動をシミュレーションする</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <div class="accordion-content">
                        <p>各キャラクターカードのテーブル内にある**「再出撃時耐久値」のセルをクリック**してください。</p>
                        <p>クリックされた数値が「本来の耐久値」に対してどれくらいの割合になるか、その上のHPバーで視覚的に確認できます。</p>
                        <p class="tip"><i class="fas fa-lightbulb"></i> ヒント: セルにカーソルを合わせると、クリック可能であることが強調表示されます。</p>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header" aria-expanded="false">
                        <span><i class="fas fa-sync-alt"></i> 4. HPバーをリセットする</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <div class="accordion-content">
                        <p>シミュレーションを終了してHPバーを100%の状態に戻したい場合は、**キャラクターカードの「本来の耐久値」の数値をクリック**してください。</p>
                        <p>いつでも元の満タン状態に戻して、別の再出撃時耐久値を比較できます。</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 新規追加: 再出撃シミュレーションセクション -->
        <div class="simulation-container">
            <h2><i class="fas fa-robot"></i> 再出撃シミュレーション</h2>
            <p class="guide-intro">自機と相方を選択し、現在のチーム残りコストを入力することで、どちらかの機体が再出撃した場合の耐久値をシミュレーションできます。</p>

            <div class="character-select-group">
                <div class="select-wrapper">
                    <label for="playerCharSelect"><i class="fas fa-user-astronaut"></i> 自機:</label>
                    <select id="playerCharSelect" class="select-dropdown"></select>
                </div>
                <div class="select-wrapper">
                    <label for="partnerCharSelect"><i class="fas fa-user-friends"></i> 相方:</label>
                    <select id="partnerCharSelect" class="select-dropdown"></select>
                </div>
            </div>

            <div class="team-cost-display">
                <span class="cost-label"><i class="fas fa-users-cog"></i> チーム合計コスト:</span>
                <span id="totalTeamCost" class="cost-value">0.0</span>
            </div>

            <div class="selected-characters-display" id="selectedCharsDisplay">
                <!-- 選択された自機と相方のミニカードがここに表示される -->
            </div>

            <div class="simulation-input-group">
                <label for="remainingTeamCostInput"><i class="fas fa-coins"></i> 指定キャラ撃墜後の残りコスト:</label>
                <select id="remainingTeamCostInput" class="select-dropdown"></select>
            </div>

            <div class="simulation-buttons">
                <button id="simulatePlayerRedeploy" class="simulation-button">自機が再出撃した場合</button>
                <button id="simulatePartnerRedeploy" class="simulation-button">相方が再出撃した場合</button>
            </div>

            <div class="simulation-results" id="simulationResults">
                <h3><i class="fas fa-bolt"></i> 再出撃予測結果</h3>
                <div class="result-display-area">
                    <div class="redeploy-char-info">
                        <span class="info-label">再出撃機体:</span> <span id="redeployCharName" class="info-value">--</span>
                    </div>
                    <div class="redeploy-char-info">
                        <span class="info-label">機体コスト:</span> <span id="redeployCharCost" class="info-value">--</span>
                    </div>
                    <div class="redeploy-char-info">
                        <span class="info-label">本来の耐久値:</span> <span id="redeployOriginalHp" class="info-value">--</span>
                    </div>
                    <div class="redeploy-char-info">
                        <span class="info-label">再出撃時コスト消費:</span> <span id="redeployCostConsumed" class="info-value">--</span>
                    </div>
                    <div class="redeploy-char-info">
                        <span class="info-label">再出撃時耐久値:</span> <span id="redeployCalculatedHp" class="info-value">--</span>
                    </div>
                </div>
                <div class="hp-bar-container simulation-hp-bar">
                    <div class="hp-bar-fill"></div>
                </div>
                <div class="hp-percentage-display simulation-hp-percentage"></div>

                <!-- Awakening Simulation Area with new features -->
                <div class="awakening-simulation-area">
                    <h4><i class="fas fa-brain"></i> 覚醒ゲージ予測</h4>
                    <div class="simulation-input-group">
                        <label for="beforeShotdownAwakeningGaugeInput"><i class="fas fa-meteor"></i> 覚醒が溜まるか調べたい覚醒ゲージ:</label>
                        <input type="number" id="beforeShotdownAwakeningGaugeInput" class="select-dropdown" min="0" max="100" step="1" value="0">
                    </div>
                    <div class="simulation-input-group">
                        <label for="beforeShotdownHpInput"><i class="fas fa-heart-broken"></i> 覚醒が溜まるか調べたい耐久値:</label>
                        <input type="number" id="beforeShotdownHpInput" class="select-dropdown" min="0" step="1" value="0">
                    </div>

                    <div class="awakening-additional-options">
                        <div class="simulation-input-group checkbox-group">
                            <i class="fas fa-crosshairs"></i>
                            <input type="checkbox" id="considerOwnDownCheckbox">
                            <label for="considerOwnDownCheckbox">再出撃直後のゲージ量にする</label>
                        </div>

                        <div class="simulation-input-group checkbox-group has-dropdown"> <!-- Added has-dropdown for specific styling if needed -->
                            <i class="fas fa-fist-raised"></i>
                            <input type="checkbox" id="considerDamageDealtCheckbox">
                            <label for="considerDamageDealtCheckbox">与ダメージ考慮</label>
                            <div class="select-dropdown-container" id="damageDealtOptionsContainer">
                                <select id="damageDealtAwakeningBonusSelect" class="select-dropdown">
                                    <option value="0">選択なし</option>
                                    <option value="3">覚醒ゲージ+3 (ズンダ約1回分)</option>
                                    <option value="6">覚醒ゲージ+6 (ズンダ約2回分)</option>
                                    <option value="9">覚醒ゲージ+9 (ズンダ約3回分)</option>
                                </select>
                            </div>
                        </div>

                        <div class="simulation-input-group checkbox-group">
                             <i class="fas fa-user-slash"></i>
                             <input type="checkbox" id="considerPartnerDownCheckbox">
                             <label for="considerPartnerDownCheckbox">相方撃墜考慮</label>
                        </div>
                    </div>


                    <div class="result-display-area">
                         <div class="redeploy-char-info">
                            <span class="info-label">予測覚醒ゲージ:</span> <span id="predictedAwakeningGauge" class="info-value">--</span>
                        </div>
                        <div class="redeploy-char-info">
                            <span class="info-label">覚醒使用:</span> <span id="awakeningAvailability" class="info-value">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 新規追加: 合計耐久力表示エリア -->
        <div class="total-hp-display-area" id="totalHpDisplayArea">
            <h3><i class="fas fa-medal"></i> チーム合計耐久力予測</h3>
            <p class="total-hp-summary">
                選択された<span class="cost-value-small" id="selectedPlayerCharNameSummary">自機</span>と<span class="cost-value-small" id="selectedPartnerCharNameSummary">相方</span>の組み合わせで、
                高コストから落ちた場合(理想)、低コストから落ちた場合(妥協)、低コストのみ落ちた場合(爆弾)、最も非効率的な落ち方をした場合の合計耐久力を予測します。
            </p>

            <div class="total-hp-grid">
                <div class="total-hp-scenario">
                    <h4><i class="fas fa-chart-line"></i> <span id="highestHpScenarioTitle">チーム合計耐久値(最高)</span></h4>
                    <div class="redeploy-char-info">
                        <span class="info-label">合計獲得耐久値:</span> <span id="idealGainedHp" class="info-value">--</span>
                    </div>
                    <button class="total-hp-accordion-header" aria-expanded="false">
                        <span class="total-hp-accordion-title">撃墜順序と獲得HP</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <ul id="idealSequenceList" class="total-hp-accordion-content"></ul>
                </div>

                <div class="total-hp-scenario">
                    <h4><i class="fas fa-chart-area"></i> <span id="compromiseHpScenarioTitle">チーム合計耐久値(妥協)</span></h4>
                    <div class="redeploy-char-info">
                        <span class="info-label">合計獲得耐久値:</span> <span id="minGainedHpHpSpan" class="info-value">--</span>
                    </div>
                    <button class="total-hp-accordion-header" aria-expanded="false">
                        <span class="total-hp-accordion-title">撃墜順序と獲得HP</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <ul id="minSequenceList" class="total-hp-accordion-content"></ul>
                </div>

                <div class="total-hp-scenario"> <!-- チーム合計耐久値(爆弾) -->
                    <h4><i class="fas fa-bomb"></i> <span id="bombHpScenarioTitle">チーム合計耐久値(爆弾)</span></h4>
                    <div class="redeploy-char-info">
                        <span class="info-label">合計獲得耐久値:</span> <span id="bombGainedHp" class="info-value">--</span>
                    </div>
                    <button class="total-hp-accordion-header" aria-expanded="false">
                        <span class="total-hp-accordion-title">撃墜順序と獲得HP</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <ul id="bombSequenceList" class="total-hp-accordion-content"></ul>
                </div>

                <div class="total-hp-scenario"> <!-- チーム合計耐久値(最低) -->
                    <h4><i class="fas fa-arrow-down"></i> <span id="lowestHpScenarioTitle">チーム合計耐久値(最低)</span></h4>
                    <div class="redeploy-char-info">
                        <span class="info-label">合計獲得耐久値:</span> <span id="lowestGainedHp" class="info-value">--</span>
                    </div>
                    <button class="total-hp-accordion-header" aria-expanded="false">
                        <span class="total-hp-accordion-title">撃墜順序と獲得HP</span>
                        <i class="fas fa-chevron-down accordion-icon"></i>
                    </button>
                    <ul id="lowestSequenceList" class="total-hp-accordion-content"></ul>
                </div>
            </div>
        </div>

        <div class="controls-container">
            <div class="search-container">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="characterSearch" placeholder="キャラクター名で検索...">
            </div>

            <div class="filter-container">
                <div class="filter-group">
                    <span class="filter-label"><i class="fas fa-coins"></i> コスト:</span>
                    <div class="filter-buttons" id="costFilter">
                        <button class="filter-button active" data-cost="all">全て</button>
                        <button class="filter-button" data-cost="1.5">1.5</button>
                        <button class="filter-button" data-cost="2">2.0</button>
                        <button class="filter-button" data-cost="2.5">2.5</button>
                        <button class="filter-button" data-cost="3">3.0</button>
                    </div>
                </div>

                <div class="filter-group">
                    <span class="filter-label"><i class="fas fa-sort"></i> 並び替え:</span>
                    <div class="filter-buttons" id="sortFilter">
                        <button class="filter-button active" data-sort="name">名前順</button>
                        <button class="filter-button" data-sort="cost-desc">コスト</button>
                        <button class="filter-button" data-sort="cost-asc">コスト</button>
                        <button class="filter-button" data-sort="hp-desc">耐久値</button>
                        <button class="filter-button" data-sort="hp-asc">耐久値</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="character-grid" id="characterGrid"></div>
    </main>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        // Helper functions for Hiragana/Katakana conversion
        function toHiragana(str) {
            if (!str) return "";
            return str.replace(/[\u30A1-\u30F6]/g, function(match) { // Katakana to Hiragana
                var chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        }

        function toKatakana(str) {
            if (!str) return "";
            return str.replace(/[\u3041-\u3096]/g, function(match) { // Hiragana to Katakana
                var chr = match.charCodeAt(0) + 0x60;
                return String.fromCharCode(chr);
            });
        }

        const rawCharacterData = [
            { name: "グリフィン", hp: 3020, cost: 3, image: "assets/character_icons/griffin.png" },
            { name: "キャヴァリー", hp: 3003, cost: 3, image: "assets/character_icons/cavalry.png" },
            { name: "ケルビム", hp: 2953, cost: 3, image: "assets/character_icons/cherubim.png" },
            { name: "ラジエル", hp: 2953, cost: 3, image: "assets/character_icons/rasiel.png" },
            { name: "影", hp: 2909, cost: 3, image: "assets/character_icons/shadow.png" },
            { name: "ロタ", hp: 2892, cost: 3, image: "assets/character_icons/rota.png" },
            { name: "ヒカリ", hp: 2886, cost: 3, image: "assets/character_icons/hikari.png" },
            { name: "シュウウ", hp: 2886, cost: 3, image: "assets/character_icons/qiuyu.png" },
            { name: "イーザー", hp: 2886, cost: 3, image: "assets/character_icons/ether.png" },
            { name: "ライン", hp: 2850, cost: 3, image: "assets/character_icons/rhine.png" },
            { name: "エルフィン", hp: 2808, cost: 3, image: "assets/character_icons/elfin.png" },
            { name: "シャオリン", hp: 2772, cost: 2.5, image: "assets/character_icons/xiaoling.png" },
            { name: "アリス", hp: 2772, cost: 2.5, image: "assets/character_icons/aliz.png" },
            { name: "スズラン", hp: 2723, cost: 3, image: "assets/character_icons/convallaria.png" },
            { name: "轟雷改", hp: 2669, cost: 2.5, image: "assets/character_icons/gourai-kai.png" },
            { name: "フリード", hp: 2664, cost: 2.5, image: "assets/character_icons/ffreedo.png" },
            { name: "スカイセーバー", hp: 2664, cost: 2.5, image: "assets/character_icons/skysaber.png" },
            { name: "十八号", hp: 2664, cost: 2.5, image: "assets/character_icons/xviii.png" },
            { name: "カゼ", hp: 2592, cost: 2.5, image: "assets/character_icons/kaze.png" },
            { name: "シャープ", hp: 2592, cost: 2.5, image: "assets/character_icons/sharp.png" },
            { name: "ヴァルキア", hp: 2592, cost: 2.5, image: "assets/character_icons/valkia.png" },
            { name: "稲", hp: 2556, cost: 2.5, image: "assets/character_icons/ine.png" },
            { name: "エヴァ", hp: 2550, cost: 2.5, image: "assets/character_icons/iva.png" },
            { name: "アンジェリス", hp: 2500, cost: 2.5, image: "assets/character_icons/angelis.png" },
            { name: "シグナス", hp: 2492, cost: 2.5, image: "assets/character_icons/cygnus.png" },
            { name: "パラス", hp: 2448, cost: 2, image: "assets/character_icons/pallas.png" },
            { name: "ヴァーチェ", hp: 2348, cost: 2, image: "assets/character_icons/virtue.png" },
            { name: "ベータ", hp: 2340, cost: 2, image: "assets/character_icons/beta.png" },
            { name: "セラフィム", hp: 2340, cost: 2, image: "assets/character_icons/seraphim.png" },
            { name: "咲迦", hp: 2298, cost: 2, image: "assets/character_icons/emika.png" },
            { name: "スコーピオン", hp: 2268, cost: 2, image: "assets/character_icons/scorpion.png" },
            { name: "チンニ", hp: 2268, cost: 2, image: "assets/character_icons/qingni.png" },
            { name: "アイーダ", hp: 2240, cost: 2, image: "assets/character_icons/aida.png" },
            { name: "ザハロワ", hp: 2196, cost: 2, image: "assets/character_icons/zakharova.png" },
            { name: "デュカリオン", hp: 2168, cost: 2, image: "assets/character_icons/deucalion.png" },
            { name: "ヒビキ", hp: 2168, cost: 2, image: "assets/character_icons/hibiki.png" },
            { name: "ダークスター", hp: 2155, cost: 2, image: "assets/character_icons/darkstar.png" },
            { name: "スティレット", hp: 2155, cost: 2, image: "assets/character_icons/stylet.png" },
            { name: "ローランド", hp: 2088, cost: 1.5, image: "assets/character_icons/roland.png" },
            { name: "カタリナ", hp: 2080, cost: 1.5, image: "assets/character_icons/katerina.png" },
            { name: "オーキッド", hp: 1980, cost: 1.5, image: "assets/character_icons/orchid.png" },
            { name: "ヤミン", hp: 1980, cost: 1.5, image: "assets/character_icons/yammyn.png" },
            { name: "スノーウォル", hp: 1872, cost: 1.5, image: "assets/character_icons/snowowl.png" }
        ];

        const kanjiNameReadings = {
            "影": { hiragana: "かげ", katakana: "カゲ" },
            "轟雷改": { hiragana: "ごうらいかい", katakana: "ゴウライカイ" },
            "十八号": { hiragana: "じゅうはちごう", katakana: "ジュウハチゴウ" },
            "稲": { hiragana: "いね", katakana: "イネ" },
            "咲迦": { hiragana: "えみか", katakana: "エミカ" }
        };

        const characterData = rawCharacterData.map(char => {
            let yomi_hiragana, yomi_katakana;
            if (kanjiNameReadings[char.name]) {
                yomi_hiragana = kanjiNameReadings[char.name].hiragana;
                yomi_katakana = kanjiNameReadings[char.name].katakana;
            } else {
                yomi_hiragana = toHiragana(char.name);
                yomi_katakana = toKatakana(char.name);
            }
            return {
                ...char,
                yomi_hiragana,
                yomi_katakana
            };
        });


        const costRemainingMap = {
            "3.0": [0.5, 1.0, 1.5],
            "2.5": [0.5, 1.0, 1.5, 2.0],
            "2.0": [0.5, 1.0, 1.5],
            "1.5": [0.5, 1.0]
        };


        let selectedPlayerChar = null;
        let selectedPartnerChar = null;
        let currentlySimulatingCharType = null;

        const MAX_TEAM_COST = 6.0;
        const AVERAGE_GAUGE_COEFFICIENT = 0.5980;
        const AWAKENING_THRESHOLD = 50;
        const AWAKENING_BONUS_BY_COST = {
            "3.0": 22, "3": 22,
            "2.5": 22,
            "2.0": 20, "2": 20,
            "1.5": 15
        };
        const PARTNER_DOWN_AWAKENING_BONUS = {
            "3.0": 10, "3": 10,
            "2.5": 9,
            "2.0": 7, "2": 7,
            "1.5": 5
        };


        let characterGrid, characterSearchInput, searchIcon, costFilterButtons, sortFilterButtons, accordionHeaders, loadingOverlay;
        let playerCharSelect, partnerCharSelect, totalTeamCostSpan, selectedCharsDisplay, remainingTeamCostInput;
        let simulatePlayerRedeployBtn, simulatePartnerRedeployBtn, simulationResultsDiv;
        let redeployCharNameSpan, redeployCharCostSpan, redeployOriginalHpSpan, redeployCostConsumedSpan, redeployCalculatedHpSpan;
        let simulationHpBarFill, simulationHpPercentageDisplay;
        let totalHpDisplayArea, maxTeamCostValueDisplay;
        let highestHpScenarioTitleSpan, idealGainedHpSpan, idealSequenceList;
        let compromiseHpScenarioTitleSpan, minGainedHpHpSpan, minSequenceList;
        let lowestHpScenarioTitleSpan, lowestGainedHpSpan, lowestSequenceList;
        let bombHpScenarioTitleSpan, bombGainedHpSpan, bombSequenceList;
        let selectedPlayerCharNameSummary, selectedPartnerCharNameSummary;
        let beforeShotdownAwakeningGaugeInput, beforeShotdownHpInput_damageTakenInput;
        let predictedAwakeningGaugeSpan, awakeningAvailabilitySpan;
        let considerOwnDownCheckbox, considerDamageDealtCheckbox, damageDealtOptionsContainer, damageDealtAwakeningBonusSelect;
        let considerPartnerDownCheckbox;


        function showLoading() {
            if (loadingOverlay) loadingOverlay.classList.add('active');
        }
        function hideLoading() {
            if (loadingOverlay) gsap.to(loadingOverlay, { opacity: 0, duration: 0.3, onComplete: () => loadingOverlay.classList.remove('active') });
        }

        function generateCharacterCards(characters) {
            showLoading();
            gsap.to(Array.from(characterGrid.children), {
                opacity: 0, scale: 0.8, y: 50, duration: 0.2, stagger: 0.01, ease: "power2.in", overwrite: true,
                onComplete: () => {
                    characterGrid.innerHTML = '';
                    if (characters.length === 0) {
                        const noResultsMessage = document.createElement('p');
                        noResultsMessage.className = 'no-results-message';
                        noResultsMessage.textContent = 'ERROR: NO DATA FOUND';
                        characterGrid.appendChild(noResultsMessage);
                        gsap.fromTo(noResultsMessage, { opacity: 0, scale: 0.8 }, { opacity: 1, scale: 1, duration: 0.8, ease: "power2.out", delay: 0.1, animation: 'glitchDisplay 2s ease-in-out forwards', overwrite: true });
                        hideLoading();
                        return;
                    }
                    characters.forEach((character, index) => {
                        const card = document.createElement('div');
                        card.className = 'character-card';
                        card.dataset.originalHp = character.hp;
                        const applicableRemainingCosts = costRemainingMap[character.cost.toString()] || [];
                        const costOverHPs = applicableRemainingCosts.map(remainingCost => {
                            let calculatedHpForDisplay;
                            if (character.cost <= 0) calculatedHpForDisplay = 0;
                            else if (remainingCost >= character.cost) calculatedHpForDisplay = character.hp;
                            else if (remainingCost > 0) calculatedHpForDisplay = Math.round(character.hp * (remainingCost / character.cost));
                            else calculatedHpForDisplay = 0;
                            return calculatedHpForDisplay;
                        });
                        card.innerHTML = `
                            <div class="character-header"><span>${character.name}</span><span class="character-cost">コスト: ${character.cost.toFixed(1)}</span></div>
                            <div class="character-body">
                                <div class="character-image"><img src="" alt="${character.name}" class="character-icon-img"><span class="initial">${character.name.charAt(0)}</span></div>
                                <div class="character-stats"><span>本来の耐久値:</span><span class="character-hp">${character.hp.toLocaleString()}</span></div>
                                <div class="hp-bar-container"><div class="hp-bar-fill"></div></div><div class="hp-percentage-display"></div>
                                <table class="cost-table">
                                    <thead><tr><th>残りコスト</th>${applicableRemainingCosts.map(cost => `<th>${cost.toFixed(1)}</th>`).join('')}</tr></thead>
                                    <tbody><tr><td>再出撃時耐久値</td>${costOverHPs.map(hp => `<td data-redeploy-hp="${hp}">${hp.toLocaleString()}</td>`).join('')}</tr></tbody>
                                </table>
                            </div>`;
                        characterGrid.appendChild(card);
                        const imgElement = card.querySelector('.character-icon-img');
                        const initialSpan = card.querySelector('.initial');
                        if (character.image) {
                            imgElement.onload = () => { imgElement.style.display = 'block'; initialSpan.style.display = 'none'; };
                            imgElement.onerror = () => { imgElement.style.display = 'none'; initialSpan.style.display = 'flex'; };
                            imgElement.src = character.image;
                             if (imgElement.complete && imgElement.naturalWidth > 0) {
                                imgElement.style.display = 'block'; initialSpan.style.display = 'none';
                            }
                        } else { imgElement.style.display = 'none'; initialSpan.style.display = 'flex'; }
                        gsap.from(card, { opacity: 0, y: 80, scale: 0.8, rotateZ: gsap.utils.random(-5, 5), duration: 0.4, ease: "power3.out", delay: index * 0.02, overwrite: true });
                        const hpBarFill = card.querySelector('.hp-bar-fill');
                        if (hpBarFill) gsap.set(hpBarFill, { scaleX: 1 });
                    });
                    hideLoading();
                }
            });
        }

        function applyFiltersAndSearch() {
            const searchTermInputVal = characterSearchInput.value.trim();
            const inputRawLower = searchTermInputVal.toLowerCase();
            const inputHiragana = toHiragana(inputRawLower);
            const inputKatakana = toKatakana(inputRawLower);

            const activeCostFilter = document.querySelector('#costFilter .active').dataset.cost;
            const activeSortFilter = document.querySelector('#sortFilter .active').dataset.sort;
            let filteredCharacters = [...characterData];

            if (searchTermInputVal) {
                filteredCharacters = filteredCharacters.filter(c => {
                    const nameLower = c.name.toLowerCase();
                    const yomiHiraLower = c.yomi_hiragana.toLowerCase();
                    const yomiKataLower = c.yomi_katakana.toLowerCase();
                    return nameLower.includes(inputRawLower) || nameLower.includes(inputHiragana) || nameLower.includes(inputKatakana) ||
                           yomiHiraLower.includes(inputRawLower) || yomiHiraLower.includes(inputHiragana) || yomiHiraLower.includes(inputKatakana) ||
                           yomiKataLower.includes(inputRawLower) || yomiKataLower.includes(inputHiragana) || yomiKataLower.includes(inputKatakana);
                });
            }
            if (activeCostFilter !== 'all') {
                filteredCharacters = filteredCharacters.filter(c => c.cost.toString() === activeCostFilter);
            }
            switch (activeSortFilter) {
                case 'name': filteredCharacters.sort((a, b) => a.name.localeCompare(b.name, 'ja')); break;
                case 'hp-desc': filteredCharacters.sort((a, b) => b.hp - a.hp || a.name.localeCompare(b.name, 'ja')); break;
                case 'hp-asc': filteredCharacters.sort((a, b) => a.hp - b.hp || a.name.localeCompare(b.name, 'ja')); break;
                case 'cost-desc': filteredCharacters.sort((a, b) => b.cost - a.cost || a.name.localeCompare(b.name, 'ja')); break;
                case 'cost-asc': filteredCharacters.sort((a, b) => a.cost - b.cost || a.name.localeCompare(b.name, 'ja')); break;
            }
            generateCharacterCards(filteredCharacters);
        }

        function animateHpDisplay(card, targetHp) {
            const hpBarFill = card.querySelector('.hp-bar-fill');
            const originalHp = parseFloat(card.dataset.originalHp);
            const currentHpSpan = card.querySelector('.character-hp');
            const hpPercentageDisplayElement = card.querySelector('.hp-percentage-display');
            const allRedeployCellsInCard = card.querySelectorAll('.cost-table td[data-redeploy-hp]');
            gsap.killTweensOf(currentHpSpan);
            gsap.set(currentHpSpan, { color: '#E74C3C', textShadow: '0 0 5px rgba(231, 76, 60, 0.3)' });
            currentHpSpan.textContent = originalHp.toLocaleString();
            currentHpSpan.classList.remove('animating');
            gsap.killTweensOf(hpBarFill);
            if (targetHp === originalHp) {
                gsap.to(hpBarFill, { scaleX: 1, duration: 0.8, ease: "power3.out", transformOrigin: 'left center', overwrite: true });
                hpBarFill.classList.remove('hp-bar-low-pulse');
                allRedeployCellsInCard.forEach(cell => cell.classList.remove('active-hp-display'));
                currentHpSpan.classList.add('animating');
                gsap.delayedCall(0.8, () => currentHpSpan.classList.remove('animating'));
                if (hpPercentageDisplayElement) { hpPercentageDisplayElement.textContent = '100%'; hpPercentageDisplayElement.classList.add('show'); }
            } else {
                const hpPercentage = (originalHp > 0 ? (targetHp / originalHp) : 0);
                gsap.to(hpBarFill, {
                    scaleX: hpPercentage, duration: 0.8, ease: "power3.out", transformOrigin: 'left center', overwrite: true,
                    onUpdate: () => { if (hpPercentageDisplayElement) hpPercentageDisplayElement.textContent = `${Math.round(gsap.getProperty(hpBarFill, "scaleX") * 100)}%`; },
                    onComplete: () => { if (hpPercentageDisplayElement) hpPercentageDisplayElement.textContent = `${Math.round(hpPercentage * 100)}%`; }
                });
                if (hpPercentage <= 0.3) hpBarFill.classList.add('hp-bar-low-pulse'); else hpBarFill.classList.remove('hp-bar-low-pulse');
                currentHpSpan.classList.add('animating');
                gsap.delayedCall(0.8, () => currentHpSpan.classList.remove('animating'));
                if (hpPercentageDisplayElement) {
                    hpPercentageDisplayElement.classList.add('show');
                    hpPercentageDisplayElement.textContent = `${Math.round(parseFloat(gsap.getProperty(hpBarFill, "scaleX")) * 100)}%`;
                }
                allRedeployCellsInCard.forEach(cell => cell.classList.remove('active-hp-display'));
                const clickedCell = Array.from(allRedeployCellsInCard).find(cell => parseFloat(cell.dataset.redeployHp) === targetHp);
                if (clickedCell) clickedCell.classList.add('active-hp-display');
            }
        }

        let searchIconPulseTl;
        function initSearchIconPulseAnimation() {
            searchIconPulseTl = gsap.timeline({ repeat: -1, yoyo: true, defaults: { duration: 1.8, ease: "power2.inOut", overwrite: true } });
            if (searchIcon) searchIconPulseTl.to(searchIcon, { scale: 1.08, opacity: 1 });
        }

        function updateSortIcons() {
             sortFilterButtons.forEach(button => {
                const existingIcon = button.querySelector('i'); if (existingIcon) existingIcon.remove();
                const sortType = button.dataset.sort; let iconClass = '';
                if (sortType.includes('desc')) iconClass = 'fas fa-arrow-down';
                else if (sortType.includes('asc')) iconClass = 'fas fa-arrow-up';
                if (iconClass) {
                    const newIcon = document.createElement('i'); newIcon.className = iconClass;
                    if (button.classList.contains('active') && !button.hasAttribute('data-initial-sort-applied')) {
                        button.appendChild(newIcon); button.setAttribute('data-initial-sort-applied', 'true');
                    } else { button.appendChild(newIcon); }
                }
            });
        }

        function populateCharacterSelects() {
            const defaultOption = '<option value="">-- 選択してください --</option>';
            playerCharSelect.innerHTML = defaultOption; partnerCharSelect.innerHTML = defaultOption;
            characterData.forEach((char, index) => {
                const option = `<option value="${index}">${char.name} (コスト:${char.cost.toFixed(1)})</option>`;
                playerCharSelect.innerHTML += option; partnerCharSelect.innerHTML += option;
            });
        }

        function populateRemainingCostSelect() {
            remainingTeamCostInput.innerHTML = '';
            const zeroOption = document.createElement('option'); zeroOption.value = "0.0"; zeroOption.textContent = "0.0";
            remainingTeamCostInput.appendChild(zeroOption);
            for (let cost = 0.5; cost <= MAX_TEAM_COST; cost += 0.5) {
                const option = document.createElement('option'); option.value = cost.toFixed(1); option.textContent = cost.toFixed(1);
                remainingTeamCostInput.appendChild(option);
            }
        }

        function updateSelectedCharactersDisplay() {
            selectedCharsDisplay.innerHTML = '';
            const createMiniCard = (character) => {
                const miniCard = document.createElement('div'); miniCard.className = 'mini-character-card active';
                miniCard.innerHTML = `
                    <div class="char-name">${character.name}</div>
                    <div class="char-image">
                        <img src="${character.image || ''}" alt="${character.name}" class="mini-char-img" style="display: ${character.image ? 'block' : 'none'};">
                        <span class="initial" style="display: ${character.image ? 'none' : 'flex'};">${character.name.charAt(0)}</span>
                    </div>
                    <div class="char-cost">コスト: ${character.cost.toFixed(1)}</div>`;
                const imgElement = miniCard.querySelector('.mini-char-img'); const initialSpan = miniCard.querySelector('.initial');
                if (character.image && imgElement) {
                    imgElement.onload = () => { imgElement.style.display = 'block'; if(initialSpan) initialSpan.style.display = 'none'; };
                    imgElement.onerror = () => { if(imgElement) imgElement.style.display = 'none'; if(initialSpan) initialSpan.style.display = 'flex'; };
                    imgElement.src = character.image;
                    if (imgElement.complete && imgElement.naturalWidth > 0) { imgElement.style.display = 'block'; if(initialSpan) initialSpan.style.display = 'none';}
                } else if (initialSpan) { if(imgElement) imgElement.style.display = 'none'; initialSpan.style.display = 'flex';}
                return miniCard;
            };
            if (selectedPlayerChar) selectedCharsDisplay.appendChild(createMiniCard(selectedPlayerChar));
            if (selectedPartnerChar) selectedCharsDisplay.appendChild(createMiniCard(selectedPartnerChar));
            if (!selectedPlayerChar && !selectedPartnerChar) {
                selectedCharsDisplay.innerHTML = `<p style="color:var(--medium-grey); font-style:italic; margin-top:20px;">自機と相方を選択してください。</p>`;
                gsap.set(selectedCharsDisplay, { minHeight: '80px', display: 'flex', alignItems: 'center' });
            } else {
                gsap.set(selectedCharsDisplay, { minHeight: '180px' });
            }
        }

        function updateTeamCost() {
            const playerCost = selectedPlayerChar ? selectedPlayerChar.cost : 0;
            const partnerCost = selectedPartnerChar ? selectedPartnerChar.cost : 0;
            const currentTotalTeamCost = playerCost + partnerCost;
            totalTeamCostSpan.textContent = currentTotalTeamCost.toFixed(1);
            let autoCalculatedRemainingCost = MAX_TEAM_COST - currentTotalTeamCost;
            autoCalculatedRemainingCost = Math.max(0.0, Math.round(autoCalculatedRemainingCost * 2) / 2);
            const targetValue = autoCalculatedRemainingCost.toFixed(1);
            if (Array.from(remainingTeamCostInput.options).some(opt => opt.value === targetValue)) {
                remainingTeamCostInput.value = targetValue;
            } else { remainingTeamCostInput.value = "0.0"; }
            resetSimulationResults();
            findTeamHpCombinations();
        }

        function resetSimulationResults() {
            gsap.to(simulationResultsDiv, {
                opacity: 0, y: 20, duration: 0.3, ease: "power2.in",
                onComplete: () => {
                    if (simulationResultsDiv) simulationResultsDiv.classList.remove('active');
                    if (redeployCharNameSpan) redeployCharNameSpan.textContent = '--';
                    if (redeployCharCostSpan) redeployCharCostSpan.textContent = '--';
                    if (redeployOriginalHpSpan) redeployOriginalHpSpan.textContent = '--';
                    if (redeployCostConsumedSpan) redeployCostConsumedSpan.textContent = '--';
                    if (redeployCalculatedHpSpan) redeployCalculatedHpSpan.textContent = '--';
                    if (simulationHpBarFill) { simulationHpBarFill.style.transform = 'scaleX(0)'; simulationHpBarFill.classList.remove('hp-bar-low-pulse');}
                    if (simulationHpPercentageDisplay) { simulationHpPercentageDisplay.classList.remove('show'); simulationHpPercentageDisplay.textContent = '';}
                    if (redeployCalculatedHpSpan) { redeployCalculatedHpSpan.classList.remove('low-hp-value', 'red-value');}
                    const awakeningArea = document.querySelector('.awakening-simulation-area');
                    if (awakeningArea) awakeningArea.style.display = 'none';
                    if (beforeShotdownAwakeningGaugeInput) beforeShotdownAwakeningGaugeInput.value = 0;
                    if (beforeShotdownHpInput_damageTakenInput) { beforeShotdownHpInput_damageTakenInput.value = 0; beforeShotdownHpInput_damageTakenInput.style.borderColor = '';}
                    if(considerOwnDownCheckbox) considerOwnDownCheckbox.checked = false;
                    if (considerDamageDealtCheckbox) {
                        considerDamageDealtCheckbox.checked = false;
                        if(damageDealtOptionsContainer) damageDealtOptionsContainer.style.display = 'none';
                        if(damageDealtAwakeningBonusSelect) damageDealtAwakeningBonusSelect.value = "0";
                    }
                    if (considerPartnerDownCheckbox) considerPartnerDownCheckbox.checked = false;
                    if (predictedAwakeningGaugeSpan) predictedAwakeningGaugeSpan.textContent = '--';
                    if (awakeningAvailabilitySpan) { awakeningAvailabilitySpan.textContent = '--'; awakeningAvailabilitySpan.className = 'info-value';}
                }
            });
        }

        function calculateRedeployEffect(charToRedeploy, partnerChar, currentTeamCostRemaining, currentRedeployCount, isTeamHpScenario = false) {
            const charFullCost = charToRedeploy.cost;
            const originalHp = charToRedeploy.hp;
            let calculatedHpGained = 0;
            let costActuallyConsumed = 0;
            let finalNote = "";
            let teamCostAfterConsumption = currentTeamCostRemaining;

            if (currentTeamCostRemaining < 0.001 && !(isTeamHpScenario && currentTeamCostRemaining === 0 && charFullCost > 0)) {
                calculatedHpGained = 0; costActuallyConsumed = 0; finalNote = "チームコスト0のため出撃不可";
                return { hpGained: calculatedHpGained, costConsumed: costActuallyConsumed, note: finalNote, remainingCostAfterConsumption: currentTeamCostRemaining };
            }

            let hpBasedOnPreRedeployCost;
            let initialNotePart = "";
            if (currentTeamCostRemaining >= charFullCost) {
                hpBasedOnPreRedeployCost = originalHp;
                initialNotePart = `(${charFullCost.toFixed(1)}コスト換算)`;
            } else {
                hpBasedOnPreRedeployCost = (charFullCost > 0) ? Math.round(originalHp * (currentTeamCostRemaining / charFullCost)) : 0;
                initialNotePart = `コストオーバー (${currentTeamCostRemaining.toFixed(1)}コスト換算)`;
            }

            if (currentTeamCostRemaining >= charFullCost) {
                costActuallyConsumed = charFullCost;
            } else {
                costActuallyConsumed = currentTeamCostRemaining;
            }
            teamCostAfterConsumption = Math.max(0.0, currentTeamCostRemaining - costActuallyConsumed);

            calculatedHpGained = hpBasedOnPreRedeployCost;
            finalNote = initialNotePart;

            if (isTeamHpScenario) {
                if (teamCostAfterConsumption < charFullCost && teamCostAfterConsumption > 0.0001) {
                    calculatedHpGained = Math.round(originalHp * (teamCostAfterConsumption / charFullCost));
                     if (!initialNotePart.toLowerCase().includes("コストオーバー")) {
                        finalNote = `(${charFullCost.toFixed(1)}コスト換算), 消費後実質コストオーバー(${teamCostAfterConsumption.toFixed(1)}換算)`;
                    } else { // Was already a cost-over, note should reflect the new effective cost for HP
                        finalNote = `コストオーバー (${teamCostAfterConsumption.toFixed(1)}コスト換算)`;
                    }
                }
            }

            if (teamCostAfterConsumption < 0.001) {
                calculatedHpGained = 0;
                if (finalNote && !finalNote.endsWith(", ") && finalNote.length > 0) finalNote += ", ";
                else if (!finalNote) finalNote = "";
                if (!finalNote.includes("最終残りコスト0のためHP0")) {
                     finalNote += "最終残りコスト0のためHP0";
                }
            }
            if (currentTeamCostRemaining < 0.001 && costActuallyConsumed == 0 && !initialNotePart.includes("出撃不可")) {
                 finalNote = "チームコスト0のため出撃不可";
                 calculatedHpGained = 0;
            }
            return { hpGained: calculatedHpGained, costConsumed: costActuallyConsumed, note: finalNote, remainingCostAfterConsumption: teamCostAfterConsumption };
        }


        function simulateRemainingSequenceContinuous(fallingChar, initialRemainingCost, fallCountOfThisCharBeforeThisSubsequence, isTeamScenario) {
            let currentTeamCostRemaining = initialRemainingCost;
            let totalGainedHpInSubSequence = 0;
            const subSequence = [];
            let currentFallCountForChar = fallCountOfThisCharBeforeThisSubsequence;
            const maxRedeployAttempts = 5; let attemptsInSub = 0;

            while (currentTeamCostRemaining >= 0.001 && attemptsInSub < maxRedeployAttempts) {
                attemptsInSub++;
                let result = calculateRedeployEffect(fallingChar, null, currentTeamCostRemaining, currentFallCountForChar, isTeamScenario);
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001 && attemptsInSub > 1 ) break;

                subSequence.push({
                    turn: attemptsInSub, charName: fallingChar.name, charType: (fallingChar === selectedPlayerChar) ? "自機" : "相方",
                    charCost: fallingChar.cost, hpGained: result.hpGained, costConsumed: result.costConsumed,
                    remainingCost: result.remainingCostAfterConsumption.toFixed(1), note: result.note
                });
                totalGainedHpInSubSequence += result.hpGained;
                currentTeamCostRemaining = result.remainingCostAfterConsumption;
                currentFallCountForChar++;
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001) break;
            }
            return { totalHp: totalGainedHpInSubSequence, sequence: subSequence };
        }

        function simulateRemainingSequenceAlternating(charA, charB, initialRemainingCost, fallCountA_before, fallCountB_before, isTeamScenario) {
            let currentTeamCostRemaining = initialRemainingCost;
            let totalGainedHpInSubSequence = 0;
            const subSequence = [];
            let currentFallCountA = fallCountA_before; let currentFallCountB = fallCountB_before;
            const maxRedeployAttempts = 5; let attemptsInSub = 0; let nextToFallIsA = true;

            while (currentTeamCostRemaining >= 0.001 && attemptsInSub < maxRedeployAttempts) {
                attemptsInSub++;
                let charToRedeploy, currentOverallFallCountForChar;
                if (nextToFallIsA) { charToRedeploy = charA; currentOverallFallCountForChar = currentFallCountA; currentFallCountA++;}
                else { charToRedeploy = charB; currentOverallFallCountForChar = currentFallCountB; currentFallCountB++; }
                let result = calculateRedeployEffect(charToRedeploy, null, currentTeamCostRemaining, currentOverallFallCountForChar, isTeamScenario);
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001 && attemptsInSub > 1) break;

                subSequence.push({
                    turn: attemptsInSub, charName: charToRedeploy.name, charType: (charToRedeploy === selectedPlayerChar) ? "自機" : "相方",
                    charCost: charToRedeploy.cost, hpGained: result.hpGained, costConsumed: result.costConsumed,
                    remainingCost: result.remainingCostAfterConsumption.toFixed(1), note: result.note
                });
                totalGainedHpInSubSequence += result.hpGained;
                currentTeamCostRemaining = result.remainingCostAfterConsumption;
                nextToFallIsA = !nextToFallIsA;
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001) break;
            }
            return { totalHp: totalGainedHpInSubSequence, sequence: subSequence };
        }

        function simulateMinimumSequence(fallingChar, isTeamScenario) {
            let currentTeamCostRemaining = MAX_TEAM_COST;
            let totalGainedRedeployHp = 0; let redeployCountForThisCharInSequence = 0; const sequence = [];
            const maxRedeployAttempts = 10; let attempts = 0;

            while (currentTeamCostRemaining >= 0.001 && attempts < maxRedeployAttempts) {
                attempts++;
                let result = calculateRedeployEffect(fallingChar, null, currentTeamCostRemaining, redeployCountForThisCharInSequence, isTeamScenario);
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001 && attempts > 1) break;

                sequence.push({
                    turn: redeployCountForThisCharInSequence + 1, charName: fallingChar.name, charType: (fallingChar === selectedPlayerChar) ? "自機" : "相方",
                    charCost: fallingChar.cost, hpGained: result.hpGained, costConsumed: result.costConsumed,
                    remainingCost: result.remainingCostAfterConsumption.toFixed(1), note: result.note
                });
                totalGainedRedeployHp += result.hpGained;
                currentTeamCostRemaining = result.remainingCostAfterConsumption;
                redeployCountForThisCharInSequence++;
                if (result.note.includes("出撃不可") && result.hpGained <= 0 && result.costConsumed <= 0 && currentTeamCostRemaining < 0.001) break;
            }
            return { totalHp: totalGainedRedeployHp, sequence: sequence };
        }


        function findTeamHpCombinations() {
            if (!selectedPlayerChar || !selectedPartnerChar) {
                gsap.to(totalHpDisplayArea, { opacity: 0, y: 20, duration: 0.3, ease: "power2.in", onComplete: () => { /* ... reset display ... */ }});
                return;
            }
            const IS_TEAM_SCENARIO = true;

            let firstFallChar_highest, secondFallChar_highest;
            if (selectedPlayerChar.cost > selectedPartnerChar.cost) { firstFallChar_highest = selectedPlayerChar; secondFallChar_highest = selectedPartnerChar; }
            else if (selectedPartnerChar.cost > selectedPlayerChar.cost) { firstFallChar_highest = selectedPartnerChar; secondFallChar_highest = selectedPlayerChar; }
            else { if (selectedPlayerChar.hp >= selectedPartnerChar.hp) { firstFallChar_highest = selectedPlayerChar; secondFallChar_highest = selectedPartnerChar; }
                   else { firstFallChar_highest = selectedPartnerChar; secondFallChar_highest = selectedPlayerChar; } }
            let highestHpScenario = { name: "", totalHp: 0, sequence: [] };
            let currentHpForHighest = selectedPlayerChar.hp + selectedPartnerChar.hp;
            let currentCostForHighest = MAX_TEAM_COST;
            let highestSequence = [];
            let fallCount_A_highest = 0; let fallCount_B_highest = 0; let currentTurn_highest = 0;
            highestSequence.push({ turn: currentTurn_highest++, charName: "初期HP", charType: "", charCost: 0, hpGained: currentHpForHighest, costConsumed: 0, remainingCost: currentCostForHighest.toFixed(1), note: `${selectedPlayerChar.name} (${selectedPlayerChar.hp.toLocaleString()}) + ${selectedPartnerChar.name} (${selectedPartnerChar.hp.toLocaleString()})` });
            let res1_highest = calculateRedeployEffect(firstFallChar_highest, null, currentCostForHighest, fallCount_A_highest++, IS_TEAM_SCENARIO);
            currentHpForHighest += res1_highest.hpGained; currentCostForHighest = res1_highest.remainingCostAfterConsumption;
            highestSequence.push({ turn: currentTurn_highest++, charName: firstFallChar_highest.name, charType: (firstFallChar_highest === selectedPlayerChar) ? "自機" : "相方", charCost: firstFallChar_highest.cost, hpGained: res1_highest.hpGained, costConsumed: res1_highest.costConsumed, remainingCost: currentCostForHighest.toFixed(1), note: res1_highest.note });
            if (currentCostForHighest >= 0.001 && !(res1_highest.note.includes("出撃不可") && res1_highest.hpGained <= 0 && res1_highest.costConsumed <= 0 && currentCostForHighest < 0.001)) {
                let res2_highest = calculateRedeployEffect(secondFallChar_highest, null, currentCostForHighest, fallCount_B_highest++, IS_TEAM_SCENARIO);
                currentHpForHighest += res2_highest.hpGained; currentCostForHighest = res2_highest.remainingCostAfterConsumption;
                highestSequence.push({ turn: currentTurn_highest++, charName: secondFallChar_highest.name, charType: (secondFallChar_highest === selectedPlayerChar) ? "自機" : "相方", charCost: secondFallChar_highest.cost, hpGained: res2_highest.hpGained, costConsumed: res2_highest.costConsumed, remainingCost: currentCostForHighest.toFixed(1), note: res2_highest.note });
                if (currentCostForHighest >= 0.001 && !(res2_highest.note.includes("出撃不可") && res2_highest.hpGained <= 0 && res2_highest.costConsumed <= 0 && currentCostForHighest < 0.001)) {
                    const subA_h = simulateRemainingSequenceAlternating(firstFallChar_highest, secondFallChar_highest, currentCostForHighest, fallCount_A_highest, fallCount_B_highest, IS_TEAM_SCENARIO);
                    const subB_h = simulateRemainingSequenceContinuous(firstFallChar_highest, currentCostForHighest, fallCount_A_highest, IS_TEAM_SCENARIO);
                    const subC_h = simulateRemainingSequenceContinuous(secondFallChar_highest, currentCostForHighest, fallCount_B_highest, IS_TEAM_SCENARIO);
                    let bestSub_h = subA_h; if (subB_h.totalHp > bestSub_h.totalHp) bestSub_h = subB_h; if (subC_h.totalHp > bestSub_h.totalHp) bestSub_h = subC_h;
                    currentHpForHighest += bestSub_h.totalHp; let subTurnCounter = currentTurn_highest; bestSub_h.sequence.forEach(item => { highestSequence.push({ ...item, turn: subTurnCounter++ }); });
                }
            }
            highestHpScenario.totalHp = currentHpForHighest; highestHpScenario.sequence = highestSequence; highestHpScenario.name = `チーム合計耐久値(理想) (${firstFallChar_highest.name}先落ち→${secondFallChar_highest.name}後落ち後最適化)`;

            let firstFallChar_compromise, secondFallChar_compromise;
            if (selectedPlayerChar.cost < selectedPartnerChar.cost) { firstFallChar_compromise = selectedPlayerChar; secondFallChar_compromise = selectedPartnerChar; }
            else if (selectedPartnerChar.cost < selectedPlayerChar.cost) { firstFallChar_compromise = selectedPartnerChar; secondFallChar_compromise = selectedPlayerChar; }
            else { if (selectedPlayerChar.hp <= selectedPartnerChar.hp) { firstFallChar_compromise = selectedPlayerChar; secondFallChar_compromise = selectedPartnerChar; } else { firstFallChar_compromise = selectedPartnerChar; secondFallChar_compromise = selectedPlayerChar;} }
            let compromiseScenario = { name: "", totalHp: 0, sequence: [] };
            let currentHpForCompromise = selectedPlayerChar.hp + selectedPartnerChar.hp;
            let currentCostForCompromise = MAX_TEAM_COST;
            let compromiseSequence = [];
            let fallCount_A_compromise = 0; let fallCount_B_compromise = 0; let currentTurn_compromise = 0;
            compromiseSequence.push({ turn: currentTurn_compromise++, charName: "初期HP", charType: "", charCost: 0, hpGained: currentHpForCompromise, costConsumed: 0, remainingCost: currentCostForCompromise.toFixed(1), note: `${selectedPlayerChar.name} (${selectedPlayerChar.hp.toLocaleString()}) + ${selectedPartnerChar.name} (${selectedPartnerChar.hp.toLocaleString()})` });
            let res1_compromise = calculateRedeployEffect(firstFallChar_compromise, null, currentCostForCompromise, fallCount_A_compromise++, IS_TEAM_SCENARIO);
            currentHpForCompromise += res1_compromise.hpGained; currentCostForCompromise = res1_compromise.remainingCostAfterConsumption;
            compromiseSequence.push({ turn: currentTurn_compromise++, charName: firstFallChar_compromise.name, charType: (firstFallChar_compromise === selectedPlayerChar) ? "自機" : "相方", charCost: firstFallChar_compromise.cost, hpGained: res1_compromise.hpGained, costConsumed: res1_compromise.costConsumed, remainingCost: currentCostForCompromise.toFixed(1), note: res1_compromise.note });
            if(currentCostForCompromise >= 0.001 && !(res1_compromise.note.includes("出撃不可") && res1_compromise.hpGained <= 0 && res1_compromise.costConsumed <= 0 && currentCostForCompromise < 0.001)) {
                let res2_compromise = calculateRedeployEffect(secondFallChar_compromise, null, currentCostForCompromise, fallCount_B_compromise++, IS_TEAM_SCENARIO);
                currentHpForCompromise += res2_compromise.hpGained; currentCostForCompromise = res2_compromise.remainingCostAfterConsumption;
                compromiseSequence.push({ turn: currentTurn_compromise++, charName: secondFallChar_compromise.name, charType: (secondFallChar_compromise === selectedPlayerChar) ? "自機" : "相方", charCost: secondFallChar_compromise.cost, hpGained: res2_compromise.hpGained, costConsumed: res2_compromise.costConsumed, remainingCost: currentCostForCompromise.toFixed(1), note: res2_compromise.note });
                if (currentCostForCompromise >= 0.001 && !(res2_compromise.note.includes("出撃不可") && res2_compromise.hpGained <= 0 && res2_compromise.costConsumed <= 0 && currentCostForCompromise < 0.001)) {
                    const subA_c = simulateRemainingSequenceAlternating(firstFallChar_compromise, secondFallChar_compromise, currentCostForCompromise, fallCount_A_compromise, fallCount_B_compromise, IS_TEAM_SCENARIO);
                    const subB_c = simulateRemainingSequenceContinuous(firstFallChar_compromise, currentCostForCompromise, fallCount_A_compromise, IS_TEAM_SCENARIO);
                    const subC_c = simulateRemainingSequenceContinuous(secondFallChar_compromise, currentCostForCompromise, fallCount_B_compromise, IS_TEAM_SCENARIO);
                    let bestSub_c = subA_c; if (subB_c.totalHp > bestSub_c.totalHp) bestSub_c = subB_c; if (subC_c.totalHp > bestSub_c.totalHp) bestSub_c = subC_c;
                    currentHpForCompromise += bestSub_c.totalHp; let subTurnCounter_c = currentTurn_compromise; bestSub_c.sequence.forEach(item => { compromiseSequence.push({ ...item, turn: subTurnCounter_c++ }); });
                }
            }
            compromiseScenario.totalHp = currentHpForCompromise; compromiseScenario.sequence = compromiseSequence; compromiseScenario.name = `チーム合計耐久値(妥協) (${firstFallChar_compromise.name}先落ち→${secondFallChar_compromise.name}後落ち後最適化)`;

            let fallingChar_bomb;
            if (selectedPlayerChar.cost < selectedPartnerChar.cost) { fallingChar_bomb = selectedPlayerChar; }
            else if (selectedPartnerChar.cost < selectedPlayerChar.cost) { fallingChar_bomb = selectedPartnerChar; }
            else { fallingChar_bomb = (selectedPlayerChar.hp <= selectedPartnerChar.hp) ? selectedPlayerChar : selectedPartnerChar; }
            const bombFallResult = simulateMinimumSequence(fallingChar_bomb, IS_TEAM_SCENARIO);
            const bombTotalHp = selectedPlayerChar.hp + selectedPartnerChar.hp + bombFallResult.totalHp;
            let bombSequence = [ { turn: 0, charName: "初期HP", charType: "", charCost: 0, hpGained: selectedPlayerChar.hp + selectedPartnerChar.hp, costConsumed: 0, remainingCost: MAX_TEAM_COST.toFixed(1), note: `${selectedPlayerChar.name} (${selectedPlayerChar.hp.toLocaleString()}) + ${selectedPartnerChar.name} (${selectedPartnerChar.hp.toLocaleString()})` } ];
            bombFallResult.sequence.forEach(item => { bombSequence.push(item); });
            const bombResult = { name: `チーム合計耐久値(爆弾) (${fallingChar_bomb.name}のみ連続撃墜)`, totalHp: bombTotalHp, sequence: bombSequence };

            const playerFocusRedeploys = simulateMinimumSequence(selectedPlayerChar, IS_TEAM_SCENARIO);
            const lowestPlayerFocusTotalHp = selectedPlayerChar.hp + playerFocusRedeploys.totalHp;
            let lowestPlayerFocusSequence = [ { turn: 0, charName: "初期HP", charType: "", charCost: 0, hpGained: selectedPlayerChar.hp, costConsumed: 0, remainingCost: MAX_TEAM_COST.toFixed(1), note: `${selectedPlayerChar.name}(${selectedPlayerChar.hp.toLocaleString()})で開始、${selectedPlayerChar.name}が集中狙い` } ];
            playerFocusRedeploys.sequence.forEach(item => lowestPlayerFocusSequence.push(item));

            const partnerFocusRedeploys = simulateMinimumSequence(selectedPartnerChar, IS_TEAM_SCENARIO);
            const lowestPartnerFocusTotalHp = selectedPartnerChar.hp + partnerFocusRedeploys.totalHp;
            let lowestPartnerFocusSequence = [ { turn: 0, charName: "初期HP", charType: "", charCost: 0, hpGained: selectedPartnerChar.hp, costConsumed: 0, remainingCost: MAX_TEAM_COST.toFixed(1), note: `${selectedPartnerChar.name}(${selectedPartnerChar.hp.toLocaleString()})で開始、${selectedPartnerChar.name}が集中狙い` } ];
            partnerFocusRedeploys.sequence.forEach(item => lowestPartnerFocusSequence.push(item));

            let lowestResult;
            if (lowestPlayerFocusTotalHp <= lowestPartnerFocusTotalHp) {
                lowestResult = { name: `チーム合計耐久値(最低/${selectedPlayerChar.name}集中狙い)`, totalHp: lowestPlayerFocusTotalHp, sequence: lowestPlayerFocusSequence };
            } else {
                lowestResult = { name: `チーム合計耐久値(最低/${selectedPartnerChar.name}集中狙い)`, totalHp: lowestPartnerFocusTotalHp, sequence: lowestPartnerFocusSequence };
            }

            gsap.delayedCall(0.1, () => displayTotalTeamHpResults(highestHpScenario, compromiseScenario, bombResult, lowestResult));
        }

        function displayTotalTeamHpResults(idealScenario, compromiseScenario, bombScenario, lowestScenario) {
            if (maxTeamCostValueDisplay) maxTeamCostValueDisplay.textContent = MAX_TEAM_COST.toFixed(1);
            if (selectedPlayerCharNameSummary && selectedPlayerChar) selectedPlayerCharNameSummary.textContent = selectedPlayerChar.name;
            if (selectedPartnerCharNameSummary && selectedPartnerChar) selectedPartnerCharNameSummary.textContent = selectedPartnerChar.name;
            if (totalHpDisplayArea) { totalHpDisplayArea.style.opacity = 1; totalHpDisplayArea.style.transform = 'translateY(0)'; totalHpDisplayArea.classList.add('active'); } else return;
            const generateListItems = (sequence) => {
                return sequence?.map(item => {
                    const charTypeDisplay = item.charType ? ` (${item.charType})` : '';
                    const costConsumedDisplay = typeof item.costConsumed === 'number' ? item.costConsumed.toFixed(1) : String(item.costConsumed);
                    if (item.turn === 0) { return `<li>初期HP: ${item.hpGained.toLocaleString()} HP獲得 (${item.note})</li>`; }
                    else { const remainingCostDisplay = item.remainingCost !== undefined ? `, 残り: ${item.remainingCost}` : '';
                           return `<li>${item.turn}落ち: ${item.charName}${charTypeDisplay} - ${item.hpGained.toLocaleString()} HP獲得 (${item.note}${remainingCostDisplay})</li>`; }
                }).join('') || '';
            };
            if(highestHpScenarioTitleSpan) highestHpScenarioTitleSpan.textContent = idealScenario.name;
            if(idealGainedHpSpan) idealGainedHpSpan.textContent = idealScenario.totalHp?.toLocaleString() || '--';
            if(idealSequenceList) idealSequenceList.innerHTML = generateListItems(idealScenario.sequence);
            if(compromiseHpScenarioTitleSpan) compromiseHpScenarioTitleSpan.textContent = compromiseScenario.name;
            if(minGainedHpHpSpan) minGainedHpHpSpan.textContent = compromiseScenario.totalHp?.toLocaleString() || '--';
            if(minSequenceList) minSequenceList.innerHTML = generateListItems(compromiseScenario.sequence);
            if(bombHpScenarioTitleSpan) bombHpScenarioTitleSpan.textContent = bombScenario.name;
            if(bombGainedHpSpan) bombGainedHpSpan.textContent = bombScenario.totalHp?.toLocaleString() || '--';
            if(bombSequenceList) bombSequenceList.innerHTML = generateListItems(bombScenario.sequence);
            if(lowestHpScenarioTitleSpan) lowestHpScenarioTitleSpan.textContent = lowestScenario.name;
            if(lowestGainedHpSpan) lowestGainedHpSpan.textContent = lowestScenario.totalHp?.toLocaleString() || '--';
            if(lowestSequenceList) lowestSequenceList.innerHTML = generateListItems(lowestScenario.sequence);
            if (totalHpDisplayArea) gsap.to(totalHpDisplayArea, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" });
        }

        function simulateRedeploy(charType) {
            if (!selectedPlayerChar || !selectedPartnerChar) { alert("自機と相方の両方を選択してください。"); resetSimulationResults(); return; }
            currentlySimulatingCharType = charType;

            const allocatedCostForThisRedeploy = parseFloat(remainingTeamCostInput.value);
            let charToRedeploy = (charType === 'player') ? selectedPlayerChar : selectedPartnerChar;

            let calculatedHp;
            let actualCostConsumed = 0;
            const originalCharHp = charToRedeploy.hp;
            const charFullCost = charToRedeploy.cost;

            // Individual simulation: HP calculation based on allocatedCostForThisRedeploy
            // This specific simulation does NOT use the "final remaining cost 0 -> HP 0" rule from calculateRedeployEffect.
            if (charFullCost <= 0 || allocatedCostForThisRedeploy <= 0) {
                calculatedHp = 0;
            } else if (allocatedCostForThisRedeploy >= charFullCost) {
                calculatedHp = originalCharHp;
            } else { // Cost-over based on allocatedCostForThisRedeploy
                calculatedHp = Math.round(originalCharHp * (allocatedCostForThisRedeploy / charFullCost));
            }

            // Determine actual cost consumed for display (same as before)
            if (allocatedCostForThisRedeploy >= charFullCost) {
                actualCostConsumed = charFullCost;
            } else if (allocatedCostForThisRedeploy > 0) {
                actualCostConsumed = allocatedCostForThisRedeploy;
            } else {
                actualCostConsumed = 0;
            }

            redeployCharNameSpan.textContent = charToRedeploy.name;
            redeployCharCostSpan.textContent = charToRedeploy.cost.toFixed(1);
            redeployOriginalHpSpan.textContent = charToRedeploy.hp.toLocaleString();
            redeployCostConsumedSpan.textContent = actualCostConsumed.toFixed(1);
            redeployCalculatedHpSpan.textContent = calculatedHp.toLocaleString();
            const originalHpValue = charToRedeploy.hp;
            redeployCalculatedHpSpan.classList.remove('red-value', 'low-hp-value');
            if (originalHpValue > 0 && calculatedHp < originalHpValue && calculatedHp > 0) { redeployCalculatedHpSpan.classList.add('red-value'); }
            else if (calculatedHp === 0 && originalHpValue > 0) { redeployCalculatedHpSpan.classList.add('red-value'); }
            const hpPercentage = originalHpValue > 0 ? (calculatedHp / originalHpValue) : 0;
            gsap.to(simulationHpBarFill, {
                scaleX: hpPercentage, duration: 0.8, ease: "power3.out", transformOrigin: 'left center', overwrite: true,
                onUpdate: () => { if (simulationHpPercentageDisplay) simulationHpPercentageDisplay.textContent = `${Math.round(gsap.getProperty(simulationHpBarFill, "scaleX") * 100)}%`; },
                onComplete: () => { if (simulationHpPercentageDisplay) simulationHpPercentageDisplay.textContent = `${Math.round(hpPercentage * 100)}%`; }
            });
            if (hpPercentage <= 0.3) simulationHpBarFill.classList.add('hp-bar-low-pulse'); else simulationHpBarFill.classList.remove('hp-bar-low-pulse');
            if (simulationHpPercentageDisplay) simulationHpPercentageDisplay.classList.add('show');

            const targetCharForAwakeningData = charToRedeploy;
            if (beforeShotdownAwakeningGaugeInput) {
                beforeShotdownAwakeningGaugeInput.dataset.originalCharacterHp = targetCharForAwakeningData.hp;
                beforeShotdownAwakeningGaugeInput.dataset.characterCost = targetCharForAwakeningData.cost.toFixed(1);
            }
            if (beforeShotdownHpInput_damageTakenInput) {
                beforeShotdownHpInput_damageTakenInput.max = targetCharForAwakeningData.hp;
                beforeShotdownHpInput_damageTakenInput.dataset.originalCharacterHp = targetCharForAwakeningData.hp;
                beforeShotdownHpInput_damageTakenInput.dataset.characterCost = targetCharForAwakeningData.cost.toFixed(1);
            }

            gsap.fromTo(simulationResultsDiv, { opacity: 0, y: 20 }, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out", onComplete: () => {
                simulationResultsDiv.classList.add('active');
                const awakeningArea = document.querySelector('.awakening-simulation-area');
                if (awakeningArea) awakeningArea.style.display = 'block';
                calculateAndDisplayAwakeningGauge();
            }});
        };

        function calculateAndDisplayAwakeningGauge() {
            if (!predictedAwakeningGaugeSpan || !awakeningAvailabilitySpan || !beforeShotdownAwakeningGaugeInput || !beforeShotdownHpInput_damageTakenInput ||
                !considerOwnDownCheckbox || !considerDamageDealtCheckbox || !damageDealtAwakeningBonusSelect || !considerPartnerDownCheckbox) return;

            let charForBonusCost;
            if (currentlySimulatingCharType === 'player' && selectedPlayerChar) {
                charForBonusCost = selectedPlayerChar;
            } else if (currentlySimulatingCharType === 'partner' && selectedPartnerChar) {
                charForBonusCost = selectedPartnerChar;
            } else { // Fallback if context is lost or not set (should ideally not happen if simulateRedeploy sets it)
                charForBonusCost = { cost: parseFloat(beforeShotdownHpInput_damageTakenInput.dataset.characterCost || "0") };
            }

            const originalCharActualMaxHp = parseFloat(beforeShotdownHpInput_damageTakenInput.dataset.originalCharacterHp);
            const gaugeBeforeShotdown = parseFloat(beforeShotdownAwakeningGaugeInput.value) || 0;
            let damageTakenInputValue = parseFloat(beforeShotdownHpInput_damageTakenInput.value);

            if (isNaN(originalCharActualMaxHp) || !charForBonusCost || isNaN(charForBonusCost.cost) ||
                isNaN(gaugeBeforeShotdown) || isNaN(damageTakenInputValue) || originalCharActualMaxHp <= 0) {
                predictedAwakeningGaugeSpan.textContent = '---';
                awakeningAvailabilitySpan.textContent = '--'; awakeningAvailabilitySpan.className = 'info-value';
                if(beforeShotdownHpInput_damageTakenInput) beforeShotdownHpInput_damageTakenInput.style.borderColor = 'red';
                return;
            }
            if(beforeShotdownHpInput_damageTakenInput) beforeShotdownHpInput_damageTakenInput.style.borderColor = '';
            let actualDamageTaken = Math.max(0, Math.min(damageTakenInputValue, originalCharActualMaxHp));
            if(beforeShotdownHpInput_damageTakenInput.value !== actualDamageTaken.toString()) beforeShotdownHpInput_damageTakenInput.value = actualDamageTaken;

            const hpLossPercentage = (originalCharActualMaxHp > 0) ? (actualDamageTaken / originalCharActualMaxHp) * 100 : 0;
            const damageBasedGaugeIncrease = Math.floor(hpLossPercentage * AVERAGE_GAUGE_COEFFICIENT);
            let costBonusOnOwnDown = 0;
            if (considerOwnDownCheckbox.checked) {
                costBonusOnOwnDown = AWAKENING_BONUS_BY_COST[charForBonusCost.cost.toFixed(1)] || 0;
            }
            let additionalGaugeFromDamageDealt = 0;
            if (considerDamageDealtCheckbox.checked) additionalGaugeFromDamageDealt = parseInt(damageDealtAwakeningBonusSelect.value) || 0;
            let additionalGaugeFromPartnerDown = 0;
            if (considerPartnerDownCheckbox.checked) {
                additionalGaugeFromPartnerDown = PARTNER_DOWN_AWAKENING_BONUS[charForBonusCost.cost.toFixed(1)] || 0;
            }
            let finalPredictedGauge = gaugeBeforeShotdown + damageBasedGaugeIncrease + costBonusOnOwnDown + additionalGaugeFromDamageDealt + additionalGaugeFromPartnerDown;
            finalPredictedGauge = Math.max(0, Math.min(100, Math.floor(finalPredictedGauge)));
            predictedAwakeningGaugeSpan.textContent = finalPredictedGauge;
            awakeningAvailabilitySpan.classList.remove('awakening-possible', 'awakening-not-possible');
            if (finalPredictedGauge >= AWAKENING_THRESHOLD) {
                awakeningAvailabilitySpan.textContent = '使用可能'; awakeningAvailabilitySpan.classList.add('awakening-possible');
            } else {
                awakeningAvailabilitySpan.textContent = '使用不可'; awakeningAvailabilitySpan.classList.add('awakening-not-possible');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            characterGrid = document.getElementById('characterGrid');
            characterSearchInput = document.getElementById('characterSearch');
            searchIcon = document.querySelector('.search-icon');
            costFilterButtons = document.querySelectorAll('#costFilter .filter-button');
            sortFilterButtons = document.querySelectorAll('#sortFilter .filter-button');
            accordionHeaders = document.querySelectorAll('.accordion-header');
            loadingOverlay = document.getElementById('loadingOverlay');
            playerCharSelect = document.getElementById('playerCharSelect');
            partnerCharSelect = document.getElementById('partnerCharSelect');
            totalTeamCostSpan = document.getElementById('totalTeamCost');
            selectedCharsDisplay = document.getElementById('selectedCharsDisplay');
            remainingTeamCostInput = document.getElementById('remainingTeamCostInput');
            simulatePlayerRedeployBtn = document.getElementById('simulatePlayerRedeploy');
            simulatePartnerRedeployBtn = document.getElementById('simulatePartnerRedeploy');
            simulationResultsDiv = document.getElementById('simulationResults');
            redeployCharNameSpan = document.getElementById('redeployCharName');
            redeployCharCostSpan = document.getElementById('redeployCharCost');
            redeployOriginalHpSpan = document.getElementById('redeployOriginalHp');
            redeployCostConsumedSpan = document.getElementById('redeployCostConsumed');
            redeployCalculatedHpSpan = document.getElementById('redeployCalculatedHp');
            if (simulationResultsDiv) {
                 simulationHpBarFill = simulationResultsDiv.querySelector('.hp-bar-fill');
                 simulationHpPercentageDisplay = simulationResultsDiv.querySelector('.hp-percentage-display');
            }
            totalHpDisplayArea = document.getElementById('totalHpDisplayArea');
            // maxTeamCostValueDisplay might not be used, so check existence if relying on it
            highestHpScenarioTitleSpan = document.getElementById('highestHpScenarioTitle');
            idealGainedHpSpan = document.getElementById('idealGainedHp');
            idealSequenceList = document.getElementById('idealSequenceList');
            compromiseHpScenarioTitleSpan = document.getElementById('compromiseHpScenarioTitle');
            minGainedHpHpSpan = document.getElementById('minGainedHpHpSpan');
            minSequenceList = document.getElementById('minSequenceList');
            lowestHpScenarioTitleSpan = document.getElementById('lowestHpScenarioTitle');
            lowestGainedHpSpan = document.getElementById('lowestGainedHp');
            lowestSequenceList = document.getElementById('lowestSequenceList');
            bombHpScenarioTitleSpan = document.getElementById('bombHpScenarioTitle');
            bombGainedHpSpan = document.getElementById('bombGainedHp');
            bombSequenceList = document.getElementById('bombSequenceList');
            selectedPlayerCharNameSummary = document.getElementById('selectedPlayerCharNameSummary');
            selectedPartnerCharNameSummary = document.getElementById('selectedPartnerCharNameSummary');
            beforeShotdownAwakeningGaugeInput = document.getElementById('beforeShotdownAwakeningGaugeInput');
            beforeShotdownHpInput_damageTakenInput = document.getElementById('beforeShotdownHpInput');
            predictedAwakeningGaugeSpan = document.getElementById('predictedAwakeningGauge');
            awakeningAvailabilitySpan = document.getElementById('awakeningAvailability');
            considerOwnDownCheckbox = document.getElementById('considerOwnDownCheckbox');
            considerDamageDealtCheckbox = document.getElementById('considerDamageDealtCheckbox');
            damageDealtOptionsContainer = document.getElementById('damageDealtOptionsContainer');
            damageDealtAwakeningBonusSelect = document.getElementById('damageDealtAwakeningBonusSelect');
            considerPartnerDownCheckbox = document.getElementById('considerPartnerDownCheckbox');

            [ beforeShotdownAwakeningGaugeInput, beforeShotdownHpInput_damageTakenInput, damageDealtAwakeningBonusSelect, considerOwnDownCheckbox, considerPartnerDownCheckbox, considerDamageDealtCheckbox ].forEach(el => {
                if (el) {
                    if (el.type === 'checkbox' || el.tagName === 'SELECT') el.addEventListener('change', calculateAndDisplayAwakeningGauge);
                    else el.addEventListener('input', calculateAndDisplayAwakeningGauge);
                }
            });
            if(considerDamageDealtCheckbox && damageDealtOptionsContainer) {
                considerDamageDealtCheckbox.addEventListener('change', function() {
                    damageDealtOptionsContainer.style.display = this.checked ? 'block' : 'none';
                    if (!this.checked && damageDealtAwakeningBonusSelect) damageDealtAwakeningBonusSelect.value = "0";
                });
            }

            const tl = gsap.timeline({ defaults: { opacity: 0, ease: "power3.out", overwrite: true } });
            tl.from("h1", { y: -50, duration: 1, scale: 0.8, delay: 0.5 })
                .from(".usage-guide-container", { y: 50, duration: 0.8 }, "-=0.5")
                .from(".simulation-container", { y: 50, duration: 0.8 }, "-=0.4")
                .from(".total-hp-display-area", { y: 50, duration: 0.8 }, "-=0.3")
                .from(".controls-container", { y: 50, duration: 0.7 }, "-=0.4")
                .add(initSearchIconPulseAnimation)
                .add(populateCharacterSelects)
                .add(populateRemainingCostSelect)
                .add(applyFiltersAndSearch, "-=0.3")
                .add(updateSortIcons, "+=0.1");

            let isComposing = false; let searchTimeout;
            if(characterSearchInput) {
                characterSearchInput.addEventListener('compositionstart', () => { isComposing = true; clearTimeout(searchTimeout); });
                characterSearchInput.addEventListener('compositionend', () => { isComposing = false; clearTimeout(searchTimeout); applyFiltersAndSearch(); });
                characterSearchInput.addEventListener('input', () => { if (!isComposing) { clearTimeout(searchTimeout); searchTimeout = setTimeout(applyFiltersAndSearch, 300); }});
                characterSearchInput.addEventListener('blur', () => { if (!isComposing) { clearTimeout(searchTimeout); applyFiltersAndSearch(); }});
            }
            if(costFilterButtons) costFilterButtons.forEach(button => button.addEventListener('click', () => { costFilterButtons.forEach(btn => btn.classList.remove('active')); button.classList.add('active'); applyFiltersAndSearch(); }));
            if(sortFilterButtons) sortFilterButtons.forEach(button => button.addEventListener('click', () => { sortFilterButtons.forEach(btn => btn.classList.remove('active')); button.classList.add('active'); updateSortIcons(); applyFiltersAndSearch(); }));
            if(accordionHeaders) {
                accordionHeaders.forEach(header => {
                    header.addEventListener('click', function() {
                        const content = this.nextElementSibling; const isExpanded = this.getAttribute('aria-expanded') === 'true';
                        this.setAttribute('aria-expanded', !isExpanded); this.classList.toggle('active'); content.classList.toggle('show');
                        if (!isExpanded) gsap.to(content, { maxHeight: content.scrollHeight + "px", paddingTop: "25px", paddingBottom: "25px", opacity: 1, scaleY: 1, duration: 0.4, ease: "cubic-bezier(0.25, 0.46, 0.45, 0.94)"});
                        else gsap.to(content, { maxHeight: 0, paddingTop: 0, paddingBottom: 0, opacity: 0, scaleY: 0.8, duration: 0.4, ease: "cubic-bezier(0.25, 0.46, 0.45, 0.94)"});
                    });
                });
            }
            const totalHpAccordionHeaders = document.querySelectorAll('.total-hp-accordion-header');
            if (totalHpAccordionHeaders) {
                totalHpAccordionHeaders.forEach(header => {
                    header.addEventListener('click', function() {
                        this.classList.toggle('active'); this.setAttribute('aria-expanded', this.classList.contains('active'));
                        const content = this.nextElementSibling; const isShown = content.classList.toggle('show');
                        if (isShown) gsap.to(content, { maxHeight: "300px", opacity: 1, paddingTop: "8px", paddingBottom: "8px", marginTop: "10px", borderWidth: "1px", duration: 0.4, ease: "power2.out" });
                        else gsap.to(content, { maxHeight: 0, opacity: 0, paddingTop: 0, paddingBottom: 0, marginTop: 0, borderWidth: "0px", duration: 0.4, ease: "power2.in" });
                    });
                });
            }
            if(characterGrid) characterGrid.addEventListener('click', (event) => {
                const clickedElement = event.target; const card = clickedElement.closest('.character-card'); if (!card) return;
                const originalHp = parseFloat(card.dataset.originalHp);
                const clickedRedeployCell = clickedElement.closest('.cost-table td[data-redeploy-hp]');
                if (clickedRedeployCell) animateHpDisplay(card, parseFloat(clickedRedeployCell.dataset.redeployHp));
                else if (clickedElement.classList.contains('character-hp')) animateHpDisplay(card, originalHp);
            });
            if(simulatePlayerRedeployBtn) simulatePlayerRedeployBtn.addEventListener('click', () => simulateRedeploy('player'));
            if(simulatePartnerRedeployBtn) simulatePartnerRedeployBtn.addEventListener('click', () => simulateRedeploy('partner'));
            if(playerCharSelect) playerCharSelect.addEventListener('change', (event) => { selectedPlayerChar = event.target.value ? characterData[parseInt(event.target.value)] : null; updateTeamCost(); updateSelectedCharactersDisplay(); });
            if(partnerCharSelect) partnerCharSelect.addEventListener('change', (event) => { selectedPartnerChar = event.target.value ? characterData[parseInt(event.target.value)] : null; updateTeamCost(); updateSelectedCharactersDisplay(); });
            updateTeamCost(); updateSelectedCharactersDisplay(); resetSimulationResults();
        });
    </script>
</body>
<footer>
    <p>© 2025 May 22, Lu:Na:Clock</p>
</footer>
</html>